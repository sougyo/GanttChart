<!--
  Copyright 2026 Shogo Matsumoto

  Licensed under the Apache License, Version 2.0 (the "License");
  you may not use this file except in compliance with the License.
  You may obtain a copy of the License at

      http://www.apache.org/licenses/LICENSE-2.0

  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an "AS IS" BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License.
-->
<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>„Ç¨„É≥„Éà„ÉÅ„É£„Éº„Éà</title>
<style>
:root {
  --font-size: 14px;
  --row-height: 44px;
  --header-height: 36px;
  --sidebar-width: 180px;
  --col-width: 80px;
  --bar-height: 24px;
  --border-color: #d0d0d0;
  --header-bg: #f0f4f8;
  --row-even-bg: #fafbfc;
  --row-odd-bg: #ffffff;
  --accent: #2196F3;
}
* { margin: 0; padding: 0; box-sizing: border-box; }
body { font-family: 'Segoe UI', 'Hiragino Sans', 'Meiryo', sans-serif; font-size: var(--font-size); background: #eef1f5; color: #333; }

#toolbar {
  display: flex; flex-wrap: wrap; align-items: center; gap: 8px;
  padding: 8px 12px; background: #fff; border-bottom: 1px solid #ccc;
  box-shadow: 0 1px 3px rgba(0,0,0,.08); position: sticky; top: 0; z-index: 100;
}
#toolbar label { font-size: 0.85em; color: #555; }
#toolbar select, #toolbar input, #toolbar button {
  font-size: 0.85em; padding: 4px 8px; border: 1px solid #bbb; border-radius: 4px;
}
#toolbar button {
  background: #fff; cursor: pointer; transition: background .15s;
}
#toolbar button:hover { background: #e3f0fc; }
#toolbar button.active { background: var(--accent); color: #fff; border-color: var(--accent); }
.toolbar-sep { width: 1px; height: 24px; background: #ccc; margin: 0 4px; }
.toolbar-group { display: flex; align-items: center; gap: 4px; }

#gantt-wrapper {
  display: grid;
  grid-template-columns: var(--sidebar-width) 1fr;
  grid-template-rows: var(--header-height) 1fr;
  margin: 12px;
  background: #fff;
  border: 1px solid #bbb;
  border-radius: 6px;
  overflow: hidden;
  box-shadow: 0 2px 8px rgba(0,0,0,.07);
}
#gantt-corner {
  grid-row: 1; grid-column: 1;
  background: var(--header-bg);
  border-right: 2px solid var(--border-color);
  border-bottom: 2px solid var(--border-color);
  display: flex; align-items: center; justify-content: center;
  font-weight: bold; font-size: 0.85em; color: #666;
}
#gantt-header-scroll {
  grid-row: 1; grid-column: 2;
  overflow: hidden;
  border-bottom: 2px solid var(--border-color);
  background: var(--header-bg);
}
#gantt-header {
  display: flex; height: 100%;
}
.header-cell {
  flex: 0 0 var(--col-width);
  border-right: 1px solid var(--border-color);
  display: flex; align-items: flex-end;
  padding: 2px 4px; font-size: 0.85em; color: #555; font-weight: 600;
  white-space: nowrap; overflow: hidden;
}
.header-cell.year-start { border-left: 2px solid #999; }

#gantt-sidebar-scroll {
  grid-row: 2; grid-column: 1;
  overflow: hidden;
  border-right: 2px solid var(--border-color);
}
#gantt-sidebar { }
.sidebar-row {
  border-bottom: 1px solid var(--border-color);
  display: flex; align-items: center;
  padding: 0 6px; gap: 4px;
}
.sidebar-row:nth-child(even) { background: var(--row-even-bg); }
.sidebar-name {
  flex: 1; overflow: hidden; text-overflow: ellipsis; white-space: nowrap;
  outline: none; font-size: inherit; border: none; background: transparent;
  padding: 2px 4px; border-radius: 3px;
}
.sidebar-name:focus { background: #e8f0fe; }
.sidebar-name[contenteditable="false"] { cursor: default; }
.sidebar-btns { display: flex; gap: 2px; opacity: 0; transition: opacity .15s; }
.sidebar-row:hover .sidebar-btns { opacity: 1; }
.sidebar-btns button {
  width: 20px; height: 20px; border: none; background: transparent;
  cursor: pointer; font-size: 14px; color: #888; border-radius: 3px; line-height: 20px; padding: 0;
}
.sidebar-btns button:hover { background: #ddd; color: #333; }
.sidebar-visibility {
  cursor: pointer; font-size: 14px; flex-shrink: 0; width: 20px; text-align: center;
  user-select: none; color: #888; opacity: 0.7;
}
.sidebar-visibility:hover { opacity: 1; }
.sidebar-row.row-hidden .sidebar-name { color: #bbb; text-decoration: line-through; }
.sidebar-drag-handle {
  cursor: grab; color: #bbb; font-size: 14px; padding: 0 2px;
  user-select: none; flex-shrink: 0;
}
.sidebar-drag-handle:hover { color: #666; }
.sidebar-row.drag-over-above { box-shadow: inset 0 3px 0 0 var(--accent); }
.sidebar-row.drag-over-below { box-shadow: inset 0 -3px 0 0 var(--accent); }
.sidebar-row.dragging { opacity: 0.4; }

#gantt-body-scroll {
  grid-row: 2; grid-column: 2;
  overflow: auto;
  position: relative;
}
#gantt-body {
  position: relative;
}
.body-row {
  display: flex;
  border-bottom: 1px solid var(--border-color);
}
.body-row:nth-child(even) { background: var(--row-even-bg); }
.body-cell {
  flex: 0 0 var(--col-width);
  border-right: 1px solid #e8e8e8;
  height: 100%;
}
.body-cell.year-start { border-left: 2px solid #bbb; }

#items-layer {
  position: absolute; top: 0; left: 0; pointer-events: none;
}
.gantt-item { position: absolute; pointer-events: auto; cursor: pointer; }
.gantt-task {
  height: var(--bar-height); border-radius: 4px;
  display: flex; align-items: center; justify-content: center;
  font-size: 0.8em; color: #fff; overflow: hidden;
  white-space: nowrap; text-overflow: ellipsis; padding: 0 6px;
  border: 2px solid transparent;
  transition: box-shadow .1s;
}
.gantt-task:hover { box-shadow: 0 2px 6px rgba(0,0,0,.25); }
.gantt-task.selected { border-color: var(--accent); box-shadow: 0 0 0 2px rgba(33,150,243,.3); }
.gantt-task .resize-handle {
  position: absolute; top: 0; width: 6px; height: 100%; cursor: ew-resize;
  opacity: 0;
}
.gantt-task .resize-handle.left { left: -2px; }
.gantt-task .resize-handle.right { right: -2px; }
.edit-mode .gantt-task:hover .resize-handle { opacity: 1; background: rgba(0,0,0,.15); }

.gantt-milestone {
  display: flex; align-items: center; gap: 2px;
  font-size: 0.8em; white-space: nowrap;
  border: 2px solid transparent; border-radius: 3px; padding: 1px 3px;
}
.gantt-milestone.selected { border-color: var(--accent); background: rgba(33,150,243,.08); }

.task-label { pointer-events: none; overflow: hidden; text-overflow: ellipsis; }
.task-label-outside {
  position: absolute; pointer-events: none; white-space: nowrap;
  font-size: inherit; color: #333;
}
.task-label-outside.pos-above { bottom: 100%; left: 0; margin-bottom: 1px; }
.task-label-outside.pos-below { top: 100%; left: 0; margin-top: 1px; }
.task-label-outside.pos-left { right: 100%; top: 50%; transform: translateY(-50%); margin-right: 4px; }
.task-label-outside.pos-right { left: 100%; top: 50%; transform: translateY(-50%); margin-left: 4px; }
.inline-edit {
  background: rgba(255,255,255,.95); color: #333; border: 1px solid var(--accent);
  border-radius: 3px; padding: 1px 4px; font-size: inherit;
  outline: none; min-width: 40px; max-width: 100%;
  pointer-events: auto; position: relative; z-index: 10;
}
.gantt-task .inline-edit { max-width: calc(100% - 12px); }
.gantt-milestone .inline-edit { min-width: 60px; }
.milestone-mark { font-size: 1.3em; color: #d32f2f; line-height: 1; }
.milestone-label { color: #333; }

#thunder-svg {
  position: absolute; top: 0; left: 0; pointer-events: none; z-index: 5;
}
.thunder-dot {
  pointer-events: auto; cursor: grab;
}
.thunder-dot:active { cursor: grabbing; }

/* Context Menu */
#context-menu {
  position: fixed; background: #fff; border: 1px solid #ccc; border-radius: 6px;
  box-shadow: 0 4px 16px rgba(0,0,0,.15); z-index: 200; min-width: 160px;
  padding: 4px 0; display: none;
}
#context-menu .menu-item {
  padding: 6px 16px; cursor: pointer; font-size: 0.9em;
}
#context-menu .menu-item:hover { background: #e8f0fe; }
#context-menu .menu-sep { height: 1px; background: #e0e0e0; margin: 4px 0; }

/* Modal */
.modal-overlay {
  position: fixed; top: 0; left: 0; width: 100%; height: 100%;
  background: rgba(0,0,0,.35); z-index: 300;
  display: flex; align-items: center; justify-content: center;
}
.modal {
  background: #fff; border-radius: 8px; padding: 20px; min-width: 320px;
  box-shadow: 0 8px 32px rgba(0,0,0,.2);
}
.modal h3 { margin-bottom: 12px; font-size: 1.1em; }
.modal .field { margin-bottom: 10px; }
.modal .field label { display: block; font-size: 0.85em; color: #555; margin-bottom: 3px; }
.modal .field input, .modal .field select {
  width: 100%; padding: 6px 8px; border: 1px solid #bbb; border-radius: 4px; font-size: 0.95em;
}
.modal .field .color-options { display: flex; gap: 6px; flex-wrap: wrap; }
.modal .field .color-opt {
  width: 28px; height: 28px; border-radius: 50%; cursor: pointer;
  border: 3px solid transparent; transition: border-color .1s;
}
.modal .field .color-opt.selected { border-color: #333; }
.modal .modal-btns { display: flex; justify-content: flex-end; gap: 8px; margin-top: 16px; }
.modal .modal-btns button {
  padding: 6px 18px; border: 1px solid #bbb; border-radius: 4px;
  cursor: pointer; font-size: 0.9em;
}
.modal .modal-btns .btn-primary { background: var(--accent); color: #fff; border-color: var(--accent); }

/* View mode styles */
.view-mode #gantt-wrapper { border-radius: 0; margin: 0; }
.view-mode .gantt-task { border-radius: 5px; box-shadow: 0 1px 4px rgba(0,0,0,.15); }
.view-mode .body-cell { border-right-color: #f0f0f0; }
.view-mode .sidebar-btns { display: none !important; }

/* Toast */
#toast {
  position: fixed; bottom: 20px; left: 50%; transform: translateX(-50%);
  background: #333; color: #fff; padding: 10px 24px; border-radius: 6px;
  font-size: 0.9em; z-index: 400; display: none; box-shadow: 0 4px 12px rgba(0,0,0,.3);
}
#drag-tooltip {
  position: fixed; pointer-events: none; z-index: 500;
  background: rgba(0,0,0,.8); color: #fff; padding: 3px 8px; border-radius: 4px;
  font-size: 12px; white-space: nowrap; display: none;
  transform: translate(-50%, -130%);
}
</style>
</head>
<body>

<div id="toolbar">
  <div class="toolbar-group">
    <button id="btn-edit-mode" class="active" onclick="setMode('edit')">Á∑®ÈõÜ</button>
    <button id="btn-view-mode" onclick="setMode('view')">Ë°®Á§∫</button>
  </div>
  <div class="toolbar-sep"></div>
  <div class="toolbar-group">
    <label>Âçò‰Ωç:</label>
    <select id="sel-unit" onchange="changeUnit(this.value)">
      <option value="month" selected>Êúà</option>
      <option value="week">ÈÄ±</option>
      <option value="day">Êó•</option>
    </select>
  </div>
  <div class="toolbar-sep"></div>
  <div class="toolbar-group">
    <label>ÊñáÂ≠ó:</label>
    <button onclick="changeFontSize(-1)">A-</button>
    <button onclick="changeFontSize(1)">A+</button>
  </div>
  <div class="toolbar-sep"></div>
  <div class="toolbar-group" id="edit-controls">
    <button onclick="addColumnStart()">‚ÜêÂàóËøΩÂä†</button>
    <button onclick="addColumnEnd()">ÂàóËøΩÂä†‚Üí</button>
    <button onclick="removeColumnStart()">‚ÜêÂàóÂâäÈô§</button>
    <button onclick="removeColumnEnd()">ÂàóÂâäÈô§‚Üí</button>
    <button onclick="addRow()">Ë°åËøΩÂä†</button>
  </div>
  <div class="toolbar-group" id="thunder-controls">
    <div class="toolbar-sep"></div>
    <label><input type="checkbox" id="chk-thunder" checked onchange="toggleThunder(this.checked)"> „Ç´„Éü„Éä„É™Á∑ö</label>
    <label>Âü∫Ê∫ñÊó•:</label>
    <input type="date" id="thunder-default-date" onchange="changeThunderDefault(this.value)">
  </div>
  <div class="toolbar-group" id="view-controls" style="display:none;">
    <label>ÊúüÈñì:</label>
    <input type="date" id="view-start" onchange="applyViewRange()">
    <span>„Äú</span>
    <input type="date" id="view-end" onchange="applyViewRange()">
    <button onclick="clearViewRange()">ÂÖ®ÊúüÈñì</button>
    <div class="toolbar-sep"></div>
    <button onclick="copyAsImage()">ÁîªÂÉè„Ç≥„Éî„Éº</button>
  </div>
  <div class="toolbar-sep"></div>
  <div class="toolbar-group">
    <button onclick="exportJSON()">„Ç®„ÇØ„Çπ„Éù„Éº„Éà</button>
    <button onclick="importJSON()">„Ç§„É≥„Éù„Éº„Éà</button>
  </div>
</div>

<div id="gantt-wrapper">
  <div id="gantt-corner">„Çø„Çπ„ÇØÂêç</div>
  <div id="gantt-header-scroll"><div id="gantt-header"></div></div>
  <div id="gantt-sidebar-scroll"><div id="gantt-sidebar"></div></div>
  <div id="gantt-body-scroll">
    <div id="gantt-body">
      <div id="grid-layer"></div>
      <div id="items-layer"></div>
      <svg id="thunder-svg"></svg>
    </div>
  </div>
</div>

<div id="context-menu"></div>
<div id="toast"></div>
<div id="drag-tooltip"></div>
<input type="file" id="file-input" accept=".json" style="display:none" onchange="handleFileImport(event)">

<script>
// ===== State =====
let state = {
  timeUnit: 'month',
  startDate: '2026-01-01',
  endDate: '2026-12-31',
  fontSize: 14,
  rows: [
    { name: '‰ΩúÊ•≠1', items: [] },
    { name: '‰ΩúÊ•≠2', items: [] },
    { name: '‰ΩúÊ•≠3', items: [] }
  ],
  thunderLine: { visible: true, points: [], defaultDate: fmtDate(new Date()) }
};

let appMode = 'edit'; // edit | view
let viewRange = null; // {start, end}
let selectedItems = []; // [{rowIndex, itemIndex}]
let columns = [];
let colWidth = 80;
let isDragging = false;
let dragData = null;

const COLORS = ['#4CAF50','#2196F3','#FF9800','#9C27B0','#F44336','#00BCD4','#795548','#607D8B','#E91E63','#3F51B5'];

// ===== Date Utils =====
function parseDate(s) { const p = s.split('-'); return new Date(+p[0], +p[1]-1, +p[2]); }
function fmtDate(d) { return `${d.getFullYear()}-${String(d.getMonth()+1).padStart(2,'0')}-${String(d.getDate()).padStart(2,'0')}`; }
function addDays(d, n) { const r = new Date(d); r.setDate(r.getDate()+n); return r; }
function daysBetween(a, b) { return Math.round((b.getTime()-a.getTime())/86400000); }
function monthStart(d) { return new Date(d.getFullYear(), d.getMonth(), 1); }
function monthEnd(d) { return new Date(d.getFullYear(), d.getMonth()+1, 0); }
function weekStart(d) { const r = new Date(d); const day = r.getDay(); r.setDate(r.getDate() - (day === 0 ? 6 : day - 1)); return r; }
function minDate(a,b) { return a < b ? a : b; }
function maxDate(a,b) { return a > b ? a : b; }

// ===== Column Generation =====
function generateColumns(start, end, unit) {
  const cols = [];
  const sd = parseDate(start), ed = parseDate(end);
  if (unit === 'month') {
    let cur = monthStart(sd);
    while (cur <= ed) {
      const mEnd = monthEnd(cur);
      cols.push({ start: new Date(cur), end: mEnd, label: String(cur.getMonth()+1), year: cur.getFullYear() });
      cur = new Date(cur.getFullYear(), cur.getMonth()+1, 1);
    }
  } else if (unit === 'week') {
    let cur = weekStart(sd);
    while (cur <= ed) {
      const wEnd = addDays(cur, 6);
      cols.push({ start: new Date(cur), end: wEnd, label: `${cur.getMonth()+1}/${cur.getDate()}`, year: cur.getFullYear() });
      cur = addDays(cur, 7);
    }
  } else {
    let cur = new Date(sd);
    while (cur <= ed) {
      cols.push({ start: new Date(cur), end: new Date(cur), label: `${cur.getMonth()+1}/${cur.getDate()}`, year: cur.getFullYear() });
      cur = addDays(cur, 1);
    }
  }
  return cols;
}

// Returns the LEFT edge position of the given date's slot within its column
function getXForDate(date, cols, cw) {
  const d = (typeof date === 'string') ? parseDate(date) : date;
  for (let i = 0; i < cols.length; i++) {
    if (d >= cols[i].start && d <= cols[i].end) {
      const totalDays = daysBetween(cols[i].start, cols[i].end) + 1;
      const off = daysBetween(cols[i].start, d);
      return i * cw + (off / totalDays) * cw;
    }
  }
  if (d < cols[0].start) return 0;
  return cols.length * cw;
}

// Returns the RIGHT edge position of the given date's slot
function getXForDateEnd(date, cols, cw) {
  const d = (typeof date === 'string') ? parseDate(date) : date;
  for (let i = 0; i < cols.length; i++) {
    if (d >= cols[i].start && d <= cols[i].end) {
      const totalDays = daysBetween(cols[i].start, cols[i].end) + 1;
      const off = daysBetween(cols[i].start, d);
      return i * cw + ((off + 1) / totalDays) * cw;
    }
  }
  if (d < cols[0].start) return 0;
  return cols.length * cw;
}

// Returns the CENTER position of the given date's slot (for milestones, thunder points)
function getXForDateCenter(date, cols, cw) {
  return (getXForDate(date, cols, cw) + getXForDateEnd(date, cols, cw)) / 2;
}

function getDateForX(x, cols, cw) {
  const ci = Math.floor(x / cw);
  if (ci < 0) return new Date(cols[0].start);
  if (ci >= cols.length) return new Date(cols[cols.length-1].end);
  const col = cols[ci];
  const off = x - ci * cw;
  const totalDays = daysBetween(col.start, col.end) + 1;
  const dayOff = Math.floor((off / cw) * totalDays);
  return addDays(col.start, Math.max(0, Math.min(dayOff, totalDays - 1)));
}

// ===== Rendering =====
function render() {
  const sd = viewRange ? viewRange.start : state.startDate;
  const ed = viewRange ? viewRange.end : state.endDate;
  columns = generateColumns(sd, ed, state.timeUnit);

  // In view mode, fit to container
  const bodyScroll = document.getElementById('gantt-body-scroll');
  if (appMode === 'view' && viewRange) {
    const avail = bodyScroll.clientWidth || (window.innerWidth - parseInt(getComputedStyle(document.documentElement).getPropertyValue('--sidebar-width')) - 30);
    colWidth = Math.max(30, Math.floor(avail / columns.length));
  } else {
    colWidth = state.timeUnit === 'day' ? 36 : (state.timeUnit === 'week' ? 52 : 80);
  }

  document.documentElement.style.setProperty('--col-width', colWidth + 'px');
  document.documentElement.style.setProperty('--font-size', state.fontSize + 'px');

  visibleRows = getVisibleRows();
  computeRowLayout();
  renderHeader();
  renderSidebar();
  renderBody();
  renderItems();
  renderThunderLine();
}

const BASE_ROW_HEIGHT = 44;
let rowHeights = []; // per visible row
let rowYOffsets = []; // cumulative Y for each visible row
let totalBodyHeight = 0;

function computeRowLayout() {
  const labelExtra = Math.ceil(state.fontSize * 0.8) + 4;
  rowHeights = [];
  rowYOffsets = [];
  let y = 0;
  visibleRows.forEach((entry, vi) => {
    let hasAbove = false, hasBelow = false;
    entry.row.items.forEach(item => {
      if (item.type === 'task') {
        const pos = item.taskLabelPosition || 'inside';
        if (pos === 'above') hasAbove = true;
        if (pos === 'below') hasBelow = true;
      }
    });
    const h = BASE_ROW_HEIGHT + (hasAbove ? labelExtra : 0) + (hasBelow ? labelExtra : 0);
    rowHeights.push(h);
    rowYOffsets.push(y);
    y += h;
  });
  totalBodyHeight = y;
}

function getVisibleRowIndexForY(y) {
  for (let i = 0; i < visibleRows.length; i++) {
    if (y < rowYOffsets[i] + rowHeights[i]) return i;
  }
  return visibleRows.length - 1;
}

// Returns array of {row, originalIndex} for rows to display
function getVisibleRows() {
  if (appMode === 'edit') {
    return state.rows.map((r, i) => ({ row: r, originalIndex: i }));
  }
  return state.rows
    .map((r, i) => ({ row: r, originalIndex: i }))
    .filter(entry => entry.row.visible !== false);
}

let visibleRows = [];

function renderHeader() {
  const hdr = document.getElementById('gantt-header');
  hdr.innerHTML = '';
  hdr.style.width = (columns.length * colWidth) + 'px';
  let prevYear = null;
  columns.forEach((col, i) => {
    const cell = document.createElement('div');
    cell.className = 'header-cell';
    if (col.year !== prevYear && i > 0) cell.classList.add('year-start');
    cell.style.flexBasis = colWidth + 'px';
    cell.style.minWidth = colWidth + 'px';
    let lbl = col.label;
    if (col.year !== prevYear) {
      if (state.timeUnit === 'month') lbl = col.year + '/' + lbl;
      prevYear = col.year;
    }
    cell.textContent = lbl;
    hdr.appendChild(cell);
  });
}

function renderSidebar() {
  const sb = document.getElementById('gantt-sidebar');
  sb.innerHTML = '';

  if (appMode === 'edit') {
    // Edit mode: show all rows with visibility toggle
    state.rows.forEach((row, ri) => {
      // In edit mode visibleRows = all rows, so vi === ri
      const div = document.createElement('div');
      div.className = 'sidebar-row';
      div.style.height = rowHeights[ri] + 'px';
      div.dataset.rowIndex = ri;

      const vis = document.createElement('span');
      vis.className = 'sidebar-visibility';
      vis.textContent = row.visible === false ? 'üîá' : 'üëÅ';
      vis.title = row.visible === false ? 'Ë°®Á§∫„É¢„Éº„Éâ„ÅßÈùûË°®Á§∫' : 'Ë°®Á§∫„É¢„Éº„Éâ„ÅßË°®Á§∫';
      vis.onclick = () => {
        state.rows[ri].visible = !(row.visible !== false);
        render();
      };
      div.appendChild(vis);

      const handle = document.createElement('span');
      handle.className = 'sidebar-drag-handle';
      handle.textContent = '‚ò∞';
      handle.title = '„Éâ„É©„ÉÉ„Ç∞„Åß‰∏¶„ÅπÊõø„Åà';
      handle.addEventListener('mousedown', e => startRowDrag(e, ri));
      div.appendChild(handle);

      if (row.visible === false) div.classList.add('row-hidden');

      const nameEl = document.createElement('span');
      nameEl.className = 'sidebar-name';
      nameEl.textContent = row.name;
      nameEl.contentEditable = true;
      nameEl.addEventListener('blur', () => { state.rows[ri].name = nameEl.textContent.trim() || '(Êú™Ë®≠ÂÆö)'; });
      nameEl.addEventListener('keydown', e => { if(e.key==='Enter'){e.preventDefault();nameEl.blur();} });
      div.appendChild(nameEl);

      const btns = document.createElement('div');
      btns.className = 'sidebar-btns';
      const btnDel = document.createElement('button');
      btnDel.textContent = '√ó';
      btnDel.title = 'Ë°åÂâäÈô§';
      btnDel.onclick = () => { if(state.rows.length>1){state.rows.splice(ri,1);selectedItems=[];render();} };
      const btnUp = document.createElement('button');
      btnUp.textContent = '‚Üë';
      btnUp.title = '‰∏ä„Å´Ë°åËøΩÂä†';
      btnUp.onclick = () => { state.rows.splice(ri,0,{name:'Êñ∞Ë¶è‰ΩúÊ•≠',items:[]});render(); };
      btns.appendChild(btnUp);
      btns.appendChild(btnDel);
      div.appendChild(btns);

      sb.appendChild(div);
    });
  } else {
    // View mode: show only visible rows
    visibleRows.forEach((entry, vi) => {
      const div = document.createElement('div');
      div.className = 'sidebar-row';
      div.style.height = rowHeights[vi] + 'px';
      const nameEl = document.createElement('span');
      nameEl.className = 'sidebar-name';
      nameEl.textContent = entry.row.name;
      nameEl.contentEditable = false;
      div.appendChild(nameEl);
      sb.appendChild(div);
    });
  }
}

// ===== Row Drag & Drop =====
function startRowDrag(e, fromIndex) {
  e.preventDefault();
  e.stopPropagation();
  const sb = document.getElementById('gantt-sidebar');
  const rows = sb.querySelectorAll('.sidebar-row');
  let targetIndex = fromIndex;

  rows[fromIndex].classList.add('dragging');

  function onMove(ev) {
    // Clear all indicators
    rows.forEach(r => { r.classList.remove('drag-over-above', 'drag-over-below'); });

    // Find which row the mouse is over
    const sbRect = sb.getBoundingClientRect();
    const sidebarScroll = document.getElementById('gantt-sidebar-scroll');
    const y = ev.clientY - sbRect.top + sidebarScroll.scrollTop;
    let hoverIndex = getVisibleRowIndexForY(y);
    hoverIndex = Math.max(0, Math.min(hoverIndex, state.rows.length - 1));

    if (hoverIndex === fromIndex) {
      targetIndex = fromIndex;
      return;
    }

    // Show indicator
    if (hoverIndex < fromIndex) {
      // Moving up: drop above the hovered row
      rows[hoverIndex].classList.add('drag-over-above');
      targetIndex = hoverIndex;
    } else {
      // Moving down: drop below the hovered row
      rows[hoverIndex].classList.add('drag-over-below');
      targetIndex = hoverIndex;
    }
  }

  function onUp() {
    document.removeEventListener('mousemove', onMove);
    document.removeEventListener('mouseup', onUp);
    rows.forEach(r => { r.classList.remove('dragging', 'drag-over-above', 'drag-over-below'); });

    if (targetIndex !== fromIndex) {
      moveRow(fromIndex, targetIndex);
    }
  }

  document.addEventListener('mousemove', onMove);
  document.addEventListener('mouseup', onUp);
}

function moveRow(from, to) {
  // Move the row in state.rows
  const row = state.rows.splice(from, 1)[0];
  state.rows.splice(to, 0, row);

  // Update thunder line point indices
  state.thunderLine.points.forEach(p => {
    if (p.rowIndex === from) {
      p.rowIndex = to;
    } else if (from < to) {
      // Moved down: rows between (from, to] shift up by 1
      if (p.rowIndex > from && p.rowIndex <= to) p.rowIndex--;
    } else {
      // Moved up: rows between [to, from) shift down by 1
      if (p.rowIndex >= to && p.rowIndex < from) p.rowIndex++;
    }
  });

  // Update selected items indices
  selectedItems = selectedItems.map(s => {
    let newRi = s.rowIndex;
    if (s.rowIndex === from) {
      newRi = to;
    } else if (from < to) {
      if (s.rowIndex > from && s.rowIndex <= to) newRi--;
    } else {
      if (s.rowIndex >= to && s.rowIndex < from) newRi++;
    }
    return { rowIndex: newRi, itemIndex: s.itemIndex };
  });

  render();
}

function renderBody() {
  const grid = document.getElementById('grid-layer');
  grid.innerHTML = '';
  const totalW = columns.length * colWidth;
  const body = document.getElementById('gantt-body');
  body.style.width = totalW + 'px';
  body.style.height = totalBodyHeight + 'px';
  let prevYear = null;
  visibleRows.forEach((entry, vi) => {
    const rowDiv = document.createElement('div');
    rowDiv.className = 'body-row';
    rowDiv.style.height = rowHeights[vi] + 'px';
    prevYear = null;
    columns.forEach((col, ci) => {
      const cell = document.createElement('div');
      cell.className = 'body-cell';
      cell.style.flexBasis = colWidth + 'px';
      cell.style.minWidth = colWidth + 'px';
      if (col.year !== prevYear && ci > 0) cell.classList.add('year-start');
      prevYear = col.year;
      rowDiv.appendChild(cell);
    });
    grid.appendChild(rowDiv);
  });
}

function renderItems() {
  const layer = document.getElementById('items-layer');
  layer.innerHTML = '';
  const bh = parseInt(getComputedStyle(document.documentElement).getPropertyValue('--bar-height'));

  visibleRows.forEach((entry, vi) => {
    const ri = entry.originalIndex;
    const rh = rowHeights[vi];
    const ry = rowYOffsets[vi];
    entry.row.items.forEach((item, ii) => {
      if (item.type === 'task') {
        renderTask(layer, item, ri, ii, rh, bh, ry);
      } else if (item.type === 'milestone') {
        renderMilestone(layer, item, ri, ii, rh, ry);
      }
    });
  });
}

function renderTask(layer, item, ri, ii, rh, bh, ry) {
  const x1 = getXForDate(item.startDate, columns, colWidth);
  const x2 = getXForDateEnd(item.endDate, columns, colWidth);
  if (x2 < 0 || x1 > columns.length * colWidth) return;
  const w = Math.max(x2 - x1, 6);
  const top = ry + (rh - bh) / 2;

  const el = document.createElement('div');
  el.className = 'gantt-item gantt-task';
  if (isSelected(ri, ii)) el.classList.add('selected');
  el.style.left = x1 + 'px';
  el.style.top = top + 'px';
  el.style.width = w + 'px';
  el.style.background = item.color || COLORS[0];
  const lblPos = item.taskLabelPosition || 'inside';
  if (lblPos !== 'inside') el.style.overflow = 'visible';
  let taskLabel;
  if (lblPos === 'inside') {
    taskLabel = document.createElement('span');
    taskLabel.className = 'task-label';
    taskLabel.textContent = item.label || '';
    el.appendChild(taskLabel);
  } else {
    taskLabel = document.createElement('span');
    taskLabel.className = 'task-label-outside pos-' + lblPos;
    taskLabel.textContent = item.label || '';
    el.appendChild(taskLabel);
  }
  el.title = `${item.label || ''}\n${item.startDate} „Äú ${item.endDate}`;

  if (appMode === 'edit') {
    const lHandle = document.createElement('div');
    lHandle.className = 'resize-handle left';
    lHandle.addEventListener('mousedown', e => startResize(e, ri, ii, 'left'));
    el.appendChild(lHandle);
    const rHandle = document.createElement('div');
    rHandle.className = 'resize-handle right';
    rHandle.addEventListener('mousedown', e => startResize(e, ri, ii, 'right'));
    el.appendChild(rHandle);

    el.addEventListener('mousedown', e => {
      if (e.target.classList.contains('resize-handle')) return;
      if (el.querySelector('.inline-edit')) return;
      onItemMouseDown(e, ri, ii);
    });
    el.addEventListener('dblclick', e => {
      e.stopPropagation();
      startInlineEdit(el, taskLabel, text => {
        state.rows[ri].items[ii].label = text;
        render();
      });
    });
    el.addEventListener('contextmenu', e => {
      e.preventDefault(); e.stopPropagation();
      showContextMenu(e.clientX, e.clientY, [
        { label: '‰ΩúÊ•≠„ÇíÁ∑®ÈõÜ‚Ä¶', action: () => editItemDialog(ri, ii) },
        { label: 'ÂâäÈô§', action: () => { state.rows[ri].items.splice(ii, 1); selectedItems = []; render(); } }
      ]);
    });
  }
  layer.appendChild(el);
}

function renderMilestone(layer, item, ri, ii, rh, ry) {
  const x = getXForDateCenter(item.date, columns, colWidth);
  if (x < 0 || x > columns.length * colWidth) return;
  const top = ry + rh / 2;

  const el = document.createElement('div');
  el.className = 'gantt-item gantt-milestone';
  if (isSelected(ri, ii)) el.classList.add('selected');
  el.style.top = (top - 12) + 'px';
  el.title = `${item.label || ''}\n${item.date}`;

  const pos = item.labelPosition || 'after';
  let lblEl;
  if (pos === 'before') {
    lblEl = document.createElement('span');
    lblEl.className = 'milestone-label';
    lblEl.textContent = item.label || '';
    el.appendChild(lblEl);
  }
  const mark = document.createElement('span');
  mark.className = 'milestone-mark';
  mark.textContent = '‚ñΩ';
  el.appendChild(mark);
  if (pos === 'after') {
    lblEl = document.createElement('span');
    lblEl.className = 'milestone-label';
    lblEl.textContent = item.label || '';
    el.appendChild(lblEl);
  }

  // Position: center the mark on x
  el.style.left = (x - 8) + 'px';

  if (appMode === 'edit') {
    el.addEventListener('mousedown', e => {
      if (el.querySelector('.inline-edit')) return;
      onItemMouseDown(e, ri, ii);
    });
    el.addEventListener('dblclick', e => {
      e.stopPropagation();
      if (lblEl) {
        startInlineEdit(el, lblEl, text => {
          state.rows[ri].items[ii].label = text;
          render();
        });
      }
    });
    el.addEventListener('contextmenu', e => {
      e.preventDefault(); e.stopPropagation();
      showContextMenu(e.clientX, e.clientY, [
        { label: '„Ç§„Éô„É≥„Éà„ÇíÁ∑®ÈõÜ‚Ä¶', action: () => editItemDialog(ri, ii) },
        { label: 'ÂâäÈô§', action: () => { state.rows[ri].items.splice(ii, 1); selectedItems = []; render(); } }
      ]);
    });
  }
  layer.appendChild(el);
}

function getThunderPointsForRender() {
  // Build a point for every visible row: use explicit point if exists, otherwise default date
  const defDate = state.thunderLine.defaultDate || fmtDate(new Date());
  const explicitMap = {};
  state.thunderLine.points.forEach((p, i) => {
    explicitMap[p.rowIndex] = { date: p.date, explicitIndex: i };
  });
  const allPoints = [];
  visibleRows.forEach((entry, vi) => {
    const ri = entry.originalIndex;
    if (explicitMap[ri] !== undefined) {
      allPoints.push({ rowIndex: ri, displayIndex: vi, date: explicitMap[ri].date, explicit: true, explicitIndex: explicitMap[ri].explicitIndex });
    } else {
      allPoints.push({ rowIndex: ri, displayIndex: vi, date: defDate, explicit: false, explicitIndex: -1 });
    }
  });
  return allPoints;
}

function renderThunderLine() {
  const svg = document.getElementById('thunder-svg');
  const totalW = columns.length * colWidth;
  svg.setAttribute('width', totalW);
  svg.setAttribute('height', totalBodyHeight);
  svg.innerHTML = '';

  if (!state.thunderLine.visible || visibleRows.length === 0) return;

  const pts = getThunderPointsForRender();
  const coords = pts.map(p => {
    const vi = p.displayIndex;
    return {
      x: getXForDateCenter(p.date, columns, colWidth),
      y: rowYOffsets[vi] + rowHeights[vi] / 2,
      explicit: p.explicit,
      explicitIndex: p.explicitIndex,
      rowIndex: p.rowIndex,
      displayIndex: vi
    };
  });

  if (coords.length > 0) {
    const defX = getXForDateCenter(state.thunderLine.defaultDate || fmtDate(new Date()), columns, colWidth);
    const pathParts = [];
    pathParts.push(`${defX},${0}`);
    for (let i = 0; i < coords.length; i++) {
      pathParts.push(`${coords[i].x},${coords[i].y}`);
      const boundaryY = rowYOffsets[coords[i].displayIndex] + rowHeights[coords[i].displayIndex];
      pathParts.push(`${defX},${boundaryY}`);
    }

    const polyline = document.createElementNS('http://www.w3.org/2000/svg', 'polyline');
    polyline.setAttribute('points', pathParts.join(' '));
    polyline.setAttribute('stroke', '#d32f2f');
    polyline.setAttribute('stroke-width', '2');
    polyline.setAttribute('fill', 'none');
    svg.appendChild(polyline);
  }

  // Dots
  coords.forEach((c, i) => {
    const circle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
    circle.setAttribute('cx', c.x);
    circle.setAttribute('cy', c.y);
    circle.setAttribute('r', c.explicit ? 5 : 3);
    circle.setAttribute('fill', '#d32f2f');
    if (!c.explicit) circle.setAttribute('opacity', '0.5');
    circle.classList.add('thunder-dot');
    if (appMode === 'edit') {
      circle.addEventListener('mousedown', e => {
        if (e.button !== 0) return;
        e.preventDefault(); e.stopPropagation();
        startThunderDotDrag(e, c.rowIndex, c.explicit, c.explicitIndex);
      });
      circle.addEventListener('contextmenu', e => {
        e.preventDefault(); e.stopPropagation();
        if (c.explicit) {
          showContextMenu(e.clientX, e.clientY, [
            { label: '„Ç´„Éü„Éä„É™ÁÇπ„ÇíÂâäÈô§ÔºàÂü∫Ê∫ñÊó•„Å´Êàª„ÅôÔºâ', action: () => { state.thunderLine.points.splice(c.explicitIndex, 1); render(); } }
          ]);
        }
      });
    }
    svg.appendChild(circle);
  });
}

// ===== Thunder Dot Drag =====
function startThunderDotDrag(e, rowIndex, isExplicit, explicitIndex) {
  const bodyScroll = document.getElementById('gantt-body-scroll');
  const scrollRect = bodyScroll.getBoundingClientRect();
  let pointIndex = explicitIndex;
  let moved = false;

  // If dragging a default (non-explicit) dot, create an explicit point on first move
  function ensureExplicit() {
    if (!isExplicit && pointIndex === -1) {
      const defDate = state.thunderLine.defaultDate || fmtDate(new Date());
      state.thunderLine.points.push({ rowIndex: rowIndex, date: defDate });
      pointIndex = state.thunderLine.points.length - 1;
      isExplicit = true;
    }
  }

  function onMove(ev) {
    moved = true;
    ensureExplicit();
    const mx = ev.clientX - scrollRect.left + bodyScroll.scrollLeft;
    const curDate = getDateForX(mx, columns, colWidth);
    state.thunderLine.points[pointIndex].date = fmtDate(curDate);
    showDragTooltip(ev, formatDateLabel(curDate));
    renderThunderLine();
  }

  function onUp() {
    document.removeEventListener('mousemove', onMove);
    document.removeEventListener('mouseup', onUp);
    hideDragTooltip();
    if (moved) render();
  }

  document.addEventListener('mousemove', onMove);
  document.addEventListener('mouseup', onUp);
}

// ===== Inline Edit =====
function startInlineEdit(parentEl, labelEl, onCommit) {
  if (parentEl.querySelector('.inline-edit')) return;

  const currentText = labelEl.textContent;
  labelEl.style.display = 'none';

  const input = document.createElement('input');
  input.type = 'text';
  input.className = 'inline-edit';
  input.value = currentText;

  // Insert input next to the hidden label
  labelEl.parentNode.insertBefore(input, labelEl.nextSibling);
  input.focus();
  input.select();

  let committed = false;
  function commit() {
    if (committed) return;
    committed = true;
    const newText = input.value;
    input.remove();
    labelEl.style.display = '';
    onCommit(newText);
  }
  function cancel() {
    if (committed) return;
    committed = true;
    input.remove();
    labelEl.style.display = '';
    labelEl.textContent = currentText;
  }

  input.addEventListener('keydown', e => {
    e.stopPropagation();
    if (e.key === 'Enter') { e.preventDefault(); commit(); }
    if (e.key === 'Escape') { e.preventDefault(); cancel(); }
  });
  input.addEventListener('blur', () => commit());
  input.addEventListener('mousedown', e => e.stopPropagation());
}

// ===== Selection =====
function isSelected(ri, ii) {
  return selectedItems.some(s => s.rowIndex === ri && s.itemIndex === ii);
}

function clearSelection() { selectedItems = []; }

function toggleSelect(ri, ii, multi) {
  const idx = selectedItems.findIndex(s => s.rowIndex === ri && s.itemIndex === ii);
  if (multi) {
    if (idx >= 0) selectedItems.splice(idx, 1);
    else selectedItems.push({ rowIndex: ri, itemIndex: ii });
  } else {
    if (idx >= 0 && selectedItems.length === 1) { /* already solo selected */ }
    else { selectedItems = [{ rowIndex: ri, itemIndex: ii }]; }
  }
}

// ===== Drag Tooltip =====
function showDragTooltip(ev, text) {
  const tip = document.getElementById('drag-tooltip');
  tip.textContent = text;
  tip.style.left = ev.clientX + 'px';
  tip.style.top = ev.clientY + 'px';
  tip.style.display = 'block';
}

function hideDragTooltip() {
  document.getElementById('drag-tooltip').style.display = 'none';
}

function formatDateLabel(d) {
  if (typeof d === 'string') d = parseDate(d);
  return `${d.getFullYear()}/${d.getMonth()+1}/${d.getDate()}`;
}

// ===== Drag & Resize =====
function onItemMouseDown(e, ri, ii) {
  if (e.button !== 0) return;
  e.stopPropagation();
  const wasSelected = isSelected(ri, ii);
  const multi = e.ctrlKey || e.metaKey;

  if (multi) {
    // Ctrl+click: toggle this item in/out of selection
    toggleSelect(ri, ii, true);
    if (!isSelected(ri, ii)) { render(); return; }
  } else if (!wasSelected) {
    // Click on unselected item without Ctrl: select only this one
    selectedItems = [{ rowIndex: ri, itemIndex: ii }];
  }
  // If already selected without Ctrl: keep current multi-selection for drag
  render();

  const bodyScroll = document.getElementById('gantt-body-scroll');
  const scrollRect = bodyScroll.getBoundingClientRect();
  const startBodyX = e.clientX - scrollRect.left + bodyScroll.scrollLeft;

  // Record original dates
  const originals = selectedItems.map(s => {
    const item = state.rows[s.rowIndex].items[s.itemIndex];
    if (item.type === 'task') return { startDate: item.startDate, endDate: item.endDate };
    return { date: item.date };
  });

  let moved = false;

  function onMove(ev) {
    const dx = ev.clientX - e.clientX;
    if (Math.abs(dx) < 3 && !moved) return;
    moved = true;
    const curBodyX = ev.clientX - scrollRect.left + bodyScroll.scrollLeft;
    const startDate = getDateForX(startBodyX, columns, colWidth);
    const curDate = getDateForX(curBodyX, columns, colWidth);
    const dayOffset = daysBetween(startDate, curDate);

    selectedItems.forEach((s, i) => {
      const item = state.rows[s.rowIndex].items[s.itemIndex];
      const orig = originals[i];
      if (item.type === 'task') {
        item.startDate = fmtDate(addDays(parseDate(orig.startDate), dayOffset));
        item.endDate = fmtDate(addDays(parseDate(orig.endDate), dayOffset));
      } else {
        item.date = fmtDate(addDays(parseDate(orig.date), dayOffset));
      }
    });

    // Show tooltip with current date(s)
    const first = state.rows[selectedItems[0].rowIndex].items[selectedItems[0].itemIndex];
    if (first.type === 'task') {
      showDragTooltip(ev, `${formatDateLabel(first.startDate)} „Äú ${formatDateLabel(first.endDate)}`);
    } else {
      showDragTooltip(ev, formatDateLabel(first.date));
    }

    renderItems();
    renderThunderLine();
  }

  function onUp() {
    document.removeEventListener('mousemove', onMove);
    document.removeEventListener('mouseup', onUp);
    hideDragTooltip();
    if (moved) render();
  }

  document.addEventListener('mousemove', onMove);
  document.addEventListener('mouseup', onUp);
}

function startResize(e, ri, ii, side) {
  e.preventDefault(); e.stopPropagation();
  const item = state.rows[ri].items[ii];
  if (item.type !== 'task') return;

  const bodyScroll = document.getElementById('gantt-body-scroll');
  const scrollRect = bodyScroll.getBoundingClientRect();
  const origStart = item.startDate, origEnd = item.endDate;

  function onMove(ev) {
    const mx = ev.clientX - scrollRect.left + bodyScroll.scrollLeft;
    if (side === 'left') {
      const curDate = getDateForX(mx, columns, colWidth);
      const ed = parseDate(origEnd);
      if (curDate <= ed) item.startDate = fmtDate(curDate);
      showDragTooltip(ev, formatDateLabel(item.startDate));
    } else {
      // Right edge: subtract 1px so getDateForX returns the cell the edge belongs to
      const curDate = getDateForX(Math.max(0, mx - 1), columns, colWidth);
      const sd = parseDate(origStart);
      if (curDate >= sd) item.endDate = fmtDate(curDate);
      showDragTooltip(ev, formatDateLabel(item.endDate));
    }
    renderItems();
  }

  function onUp() {
    document.removeEventListener('mousemove', onMove);
    document.removeEventListener('mouseup', onUp);
    hideDragTooltip();
    render();
  }

  document.addEventListener('mousemove', onMove);
  document.addEventListener('mouseup', onUp);
}

// ===== Context Menu =====
function showContextMenu(x, y, items) {
  const menu = document.getElementById('context-menu');
  menu.innerHTML = '';
  items.forEach(it => {
    if (it.sep) {
      const s = document.createElement('div');
      s.className = 'menu-sep';
      menu.appendChild(s);
    } else {
      const d = document.createElement('div');
      d.className = 'menu-item';
      d.textContent = it.label;
      d.onclick = () => { hideContextMenu(); it.action(); };
      menu.appendChild(d);
    }
  });
  menu.style.left = x + 'px';
  menu.style.top = y + 'px';
  menu.style.display = 'block';
}

function hideContextMenu() {
  document.getElementById('context-menu').style.display = 'none';
}

document.addEventListener('click', e => {
  if (!e.target.closest('#context-menu')) hideContextMenu();
});

// Body context menu
document.addEventListener('DOMContentLoaded', () => {
  const bodyScroll = document.getElementById('gantt-body-scroll');

  bodyScroll.addEventListener('contextmenu', e => {
    if (appMode !== 'edit') return;
    e.preventDefault();
    const rect = document.getElementById('gantt-body').getBoundingClientRect();
    const x = e.clientX - rect.left;
    const y = e.clientY - rect.top;
    const vi = getVisibleRowIndexForY(y);
    if (vi < 0 || vi >= visibleRows.length) return;
    const ri = visibleRows[vi].originalIndex;
    const clickDate = getDateForX(x, columns, colWidth);
    const clickDateStr = fmtDate(clickDate);

    const menuItems = [
      { label: `‰ΩúÊ•≠„ÇíËøΩÂä† (${clickDateStr})`, action: () => addTaskDialog(ri, clickDateStr) },
      { label: `„Ç§„Éô„É≥„Éà„ÇíËøΩÂä† (${clickDateStr})`, action: () => addMilestoneDialog(ri, clickDateStr) },
      { sep: true },
      { label: '„Ç´„Éü„Éä„É™ÁÇπ„ÇíËøΩÂä†', action: () => { addThunderPoint(ri, clickDateStr); } },
    ];

    if (selectedItems.length > 0) {
      menuItems.push({ sep: true });
      menuItems.push({ label: 'ÈÅ∏ÊäûÈ†ÖÁõÆ„ÇíÂâäÈô§', action: () => deleteSelected() });
    }

    showContextMenu(e.clientX, e.clientY, menuItems);
  });

  bodyScroll.addEventListener('mousedown', e => {
    if (e.button === 0 && !e.target.closest('.gantt-item') && !e.target.closest('.thunder-dot')) {
      clearSelection();
      render();
    }
  });

  // Sync scroll
  bodyScroll.addEventListener('scroll', () => {
    document.getElementById('gantt-header-scroll').scrollLeft = bodyScroll.scrollLeft;
    document.getElementById('gantt-sidebar-scroll').scrollTop = bodyScroll.scrollTop;
  });
});

// ===== Thunder Line =====
function addThunderPoint(ri, dateStr) {
  const existing = state.thunderLine.points.findIndex(p => p.rowIndex === ri);
  if (existing >= 0) {
    state.thunderLine.points[existing].date = dateStr;
  } else {
    state.thunderLine.points.push({ rowIndex: ri, date: dateStr });
  }
  render();
}

function toggleThunder(visible) {
  state.thunderLine.visible = visible;
  render();
}

function changeThunderDefault(dateStr) {
  state.thunderLine.defaultDate = dateStr;
  render();
}

// ===== Dialogs =====
function showModal(title, fields, onOk) {
  const overlay = document.createElement('div');
  overlay.className = 'modal-overlay';
  const modal = document.createElement('div');
  modal.className = 'modal';
  const h3 = document.createElement('h3');
  h3.textContent = title;
  modal.appendChild(h3);

  const inputs = {};
  fields.forEach(f => {
    const div = document.createElement('div');
    div.className = 'field';
    const label = document.createElement('label');
    label.textContent = f.label;
    div.appendChild(label);

    if (f.type === 'color') {
      const container = document.createElement('div');
      container.className = 'color-options';
      let selected = f.value || COLORS[0];
      COLORS.forEach(c => {
        const opt = document.createElement('div');
        opt.className = 'color-opt' + (c === selected ? ' selected' : '');
        opt.style.background = c;
        opt.onclick = () => {
          container.querySelectorAll('.color-opt').forEach(o => o.classList.remove('selected'));
          opt.classList.add('selected');
          selected = c;
          inputs[f.key] = { value: c };
        };
        container.appendChild(opt);
      });
      inputs[f.key] = { value: selected };
      div.appendChild(container);
    } else if (f.type === 'select') {
      const sel = document.createElement('select');
      f.options.forEach(o => {
        const opt = document.createElement('option');
        opt.value = o.value; opt.textContent = o.label;
        if (o.value === f.value) opt.selected = true;
        sel.appendChild(opt);
      });
      inputs[f.key] = sel;
      div.appendChild(sel);
    } else {
      const inp = document.createElement('input');
      inp.type = f.type || 'text';
      inp.value = f.value || '';
      inputs[f.key] = inp;
      div.appendChild(inp);
    }
    modal.appendChild(div);
  });

  const btns = document.createElement('div');
  btns.className = 'modal-btns';
  const btnCancel = document.createElement('button');
  btnCancel.textContent = '„Ç≠„É£„É≥„Çª„É´';
  btnCancel.onclick = () => overlay.remove();
  const btnOk = document.createElement('button');
  btnOk.className = 'btn-primary';
  btnOk.textContent = 'OK';
  btnOk.onclick = () => {
    const vals = {};
    for (const k in inputs) vals[k] = inputs[k].value;
    onOk(vals);
    overlay.remove();
  };
  btns.appendChild(btnCancel);
  btns.appendChild(btnOk);
  modal.appendChild(btns);

  overlay.appendChild(modal);
  overlay.addEventListener('mousedown', e => { if(e.target === overlay) overlay.remove(); });
  document.body.appendChild(overlay);

  // Focus first input
  const firstInput = modal.querySelector('input[type="text"], input[type="date"]');
  if (firstInput) setTimeout(() => firstInput.focus(), 50);
}

const TASK_LABEL_POS_OPTIONS = [
  { value: 'inside', label: '‰∏≠' },
  { value: 'above', label: '‰∏ä' },
  { value: 'below', label: '‰∏ã' },
  { value: 'left', label: 'Â∑¶' },
  { value: 'right', label: 'Âè≥' }
];

function addTaskDialog(ri, dateStr) {
  const endDate = fmtDate(addDays(parseDate(dateStr), 30));
  showModal('‰ΩúÊ•≠„ÇíËøΩÂä†', [
    { key: 'label', label: '„É©„Éô„É´', type: 'text', value: '' },
    { key: 'startDate', label: 'ÈñãÂßãÊó•', type: 'date', value: dateStr },
    { key: 'endDate', label: 'ÁµÇ‰∫ÜÊó•', type: 'date', value: endDate },
    { key: 'color', label: 'Ëâ≤', type: 'color', value: COLORS[0] },
    { key: 'taskLabelPosition', label: '„É©„Éô„É´‰ΩçÁΩÆ', type: 'select', value: 'inside', options: TASK_LABEL_POS_OPTIONS }
  ], vals => {
    if (!vals.startDate || !vals.endDate) return;
    state.rows[ri].items.push({
      type: 'task', startDate: vals.startDate, endDate: vals.endDate,
      label: vals.label, color: vals.color, taskLabelPosition: vals.taskLabelPosition
    });
    render();
  });
}

function addMilestoneDialog(ri, dateStr) {
  showModal('„Ç§„Éô„É≥„Éà„ÇíËøΩÂä†', [
    { key: 'label', label: '„É©„Éô„É´', type: 'text', value: '' },
    { key: 'date', label: 'Êó•‰ªò', type: 'date', value: dateStr },
    { key: 'labelPosition', label: '„É©„Éô„É´‰ΩçÁΩÆ', type: 'select', value: 'after',
      options: [{ value: 'before', label: 'Ââç' }, { value: 'after', label: 'Âæå' }] }
  ], vals => {
    if (!vals.date) return;
    state.rows[ri].items.push({
      type: 'milestone', date: vals.date,
      label: vals.label, labelPosition: vals.labelPosition
    });
    render();
  });
}

function editItemDialog(ri, ii) {
  const item = state.rows[ri].items[ii];
  if (item.type === 'task') {
    showModal('‰ΩúÊ•≠„ÇíÁ∑®ÈõÜ', [
      { key: 'label', label: '„É©„Éô„É´', type: 'text', value: item.label },
      { key: 'startDate', label: 'ÈñãÂßãÊó•', type: 'date', value: item.startDate },
      { key: 'endDate', label: 'ÁµÇ‰∫ÜÊó•', type: 'date', value: item.endDate },
      { key: 'color', label: 'Ëâ≤', type: 'color', value: item.color || COLORS[0] },
      { key: 'taskLabelPosition', label: '„É©„Éô„É´‰ΩçÁΩÆ', type: 'select', value: item.taskLabelPosition || 'inside', options: TASK_LABEL_POS_OPTIONS }
    ], vals => {
      if (!vals.startDate || !vals.endDate) return;
      item.label = vals.label;
      item.startDate = vals.startDate;
      item.endDate = vals.endDate;
      item.color = vals.color;
      item.taskLabelPosition = vals.taskLabelPosition;
      render();
    });
  } else {
    showModal('„Ç§„Éô„É≥„Éà„ÇíÁ∑®ÈõÜ', [
      { key: 'label', label: '„É©„Éô„É´', type: 'text', value: item.label },
      { key: 'date', label: 'Êó•‰ªò', type: 'date', value: item.date },
      { key: 'labelPosition', label: '„É©„Éô„É´‰ΩçÁΩÆ', type: 'select', value: item.labelPosition || 'after',
        options: [{ value: 'before', label: 'Ââç' }, { value: 'after', label: 'Âæå' }] }
    ], vals => {
      if (!vals.date) return;
      item.label = vals.label;
      item.date = vals.date;
      item.labelPosition = vals.labelPosition;
      render();
    });
  }
}

function deleteSelected() {
  // Delete in reverse order to maintain indices
  const sorted = [...selectedItems].sort((a, b) => b.rowIndex - a.rowIndex || b.itemIndex - a.itemIndex);
  sorted.forEach(s => {
    state.rows[s.rowIndex].items.splice(s.itemIndex, 1);
  });
  selectedItems = [];
  render();
}

// ===== Mode =====
function setMode(mode) {
  appMode = mode;
  document.getElementById('btn-edit-mode').classList.toggle('active', mode === 'edit');
  document.getElementById('btn-view-mode').classList.toggle('active', mode === 'view');
  document.getElementById('edit-controls').style.display = mode === 'edit' ? '' : 'none';
  document.getElementById('view-controls').style.display = mode === 'view' ? '' : 'none';
  document.body.classList.toggle('edit-mode', mode === 'edit');
  document.body.classList.toggle('view-mode', mode === 'view');

  if (mode === 'view') {
    clearSelection();
    if (!viewRange) {
      document.getElementById('view-start').value = state.startDate;
      document.getElementById('view-end').value = state.endDate;
    }
  } else {
    viewRange = null;
  }
  render();
}

// ===== Time Unit =====
function changeUnit(unit) {
  state.timeUnit = unit;
  render();
}

// ===== Font Size =====
function changeFontSize(delta) {
  state.fontSize = Math.max(8, Math.min(24, state.fontSize + delta));
  document.documentElement.style.setProperty('--font-size', state.fontSize + 'px');
  render();
}

// ===== Column Add/Remove =====
function addColumnStart() {
  const sd = parseDate(state.startDate);
  if (state.timeUnit === 'month') {
    state.startDate = fmtDate(new Date(sd.getFullYear(), sd.getMonth() - 1, 1));
  } else if (state.timeUnit === 'week') {
    state.startDate = fmtDate(addDays(sd, -7));
  } else {
    state.startDate = fmtDate(addDays(sd, -1));
  }
  render();
}

function addColumnEnd() {
  const ed = parseDate(state.endDate);
  if (state.timeUnit === 'month') {
    const next = new Date(ed.getFullYear(), ed.getMonth() + 1, 1);
    state.endDate = fmtDate(monthEnd(next));
  } else if (state.timeUnit === 'week') {
    state.endDate = fmtDate(addDays(ed, 7));
  } else {
    state.endDate = fmtDate(addDays(ed, 1));
  }
  render();
}

function removeColumnStart() {
  const sd = parseDate(state.startDate);
  let newStart;
  if (state.timeUnit === 'month') {
    newStart = new Date(sd.getFullYear(), sd.getMonth() + 1, 1);
  } else if (state.timeUnit === 'week') {
    newStart = addDays(sd, 7);
  } else {
    newStart = addDays(sd, 1);
  }
  if (newStart < parseDate(state.endDate)) {
    state.startDate = fmtDate(newStart);
    render();
  }
}

function removeColumnEnd() {
  const ed = parseDate(state.endDate);
  let newEnd;
  if (state.timeUnit === 'month') {
    newEnd = new Date(ed.getFullYear(), ed.getMonth(), 0);
  } else if (state.timeUnit === 'week') {
    newEnd = addDays(ed, -7);
  } else {
    newEnd = addDays(ed, -1);
  }
  if (newEnd > parseDate(state.startDate)) {
    state.endDate = fmtDate(newEnd);
    render();
  }
}

// ===== Row =====
function addRow() {
  state.rows.push({ name: 'Êñ∞Ë¶è‰ΩúÊ•≠', items: [] });
  render();
}

// ===== View Range =====
function applyViewRange() {
  const vs = document.getElementById('view-start').value;
  const ve = document.getElementById('view-end').value;
  if (vs && ve && vs <= ve) {
    viewRange = { start: vs, end: ve };
    render();
  }
}

function clearViewRange() {
  viewRange = null;
  document.getElementById('view-start').value = state.startDate;
  document.getElementById('view-end').value = state.endDate;
  render();
}

// ===== Export / Import =====
function exportJSON() {
  const json = JSON.stringify(state, null, 2);
  const blob = new Blob([json], { type: 'application/json' });
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url;
  a.download = 'gantt_chart.json';
  a.click();
  URL.revokeObjectURL(url);
  showToast('„Ç®„ÇØ„Çπ„Éù„Éº„Éà„Åó„Åæ„Åó„Åü');
}

function importJSON() {
  document.getElementById('file-input').click();
}

function handleFileImport(event) {
  const file = event.target.files[0];
  if (!file) return;
  const reader = new FileReader();
  reader.onload = e => {
    try {
      const data = JSON.parse(e.target.result);
      if (data.rows && data.startDate && data.endDate) {
        state = data;
        if (!state.thunderLine) state.thunderLine = { visible: true, points: [], defaultDate: fmtDate(new Date()) };
        if (!state.thunderLine.defaultDate) state.thunderLine.defaultDate = fmtDate(new Date());
        if (!state.fontSize) state.fontSize = 14;
        document.getElementById('sel-unit').value = state.timeUnit || 'month';
        document.getElementById('chk-thunder').checked = state.thunderLine.visible;
        document.getElementById('thunder-default-date').value = state.thunderLine.defaultDate;
        selectedItems = [];
        viewRange = null;
        render();
        showToast('„Ç§„É≥„Éù„Éº„Éà„Åó„Åæ„Åó„Åü');
      } else {
        alert('ÁÑ°Âäπ„Å™„Éï„Ç°„Ç§„É´ÂΩ¢Âºè„Åß„Åô„ÄÇ');
      }
    } catch (err) {
      alert('JSON„ÅÆË™≠„ÅøËæº„Åø„Å´Â§±Êïó„Åó„Åæ„Åó„Åü: ' + err.message);
    }
  };
  reader.readAsText(file);
  event.target.value = '';
}

// ===== Image Copy =====
async function copyAsImage() {
  const canvas = renderToCanvas();
  try {
    const blob = await new Promise(resolve => canvas.toBlob(resolve, 'image/png'));
    await navigator.clipboard.write([new ClipboardItem({ 'image/png': blob })]);
    showToast('ÁîªÂÉè„Çí„ÇØ„É™„ÉÉ„Éó„Éú„Éº„Éâ„Å´„Ç≥„Éî„Éº„Åó„Åæ„Åó„Åü');
  } catch (err) {
    // Fallback: download
    canvas.toBlob(blob => {
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url; a.download = 'gantt_chart.png'; a.click();
      URL.revokeObjectURL(url);
      showToast('ÁîªÂÉè„Çí„ÉÄ„Ç¶„É≥„É≠„Éº„Éâ„Åó„Åæ„Åó„Åü');
    });
  }
}

function renderToCanvas() {
  const bh = parseInt(getComputedStyle(document.documentElement).getPropertyValue('--bar-height'));
  const sw = parseInt(getComputedStyle(document.documentElement).getPropertyValue('--sidebar-width'));
  const hh = parseInt(getComputedStyle(document.documentElement).getPropertyValue('--header-height'));
  const fs = state.fontSize;

  computeRowLayout();

  const totalW = columns.length * colWidth + sw;
  const totalH = totalBodyHeight + hh;

  const dpr = window.devicePixelRatio || 1;
  const canvas = document.createElement('canvas');
  canvas.width = totalW * dpr;
  canvas.height = totalH * dpr;
  const ctx = canvas.getContext('2d');
  ctx.scale(dpr, dpr);

  // Background
  ctx.fillStyle = '#fff';
  ctx.fillRect(0, 0, totalW, totalH);

  // Header background
  ctx.fillStyle = '#f0f4f8';
  ctx.fillRect(0, 0, totalW, hh);

  // Corner
  ctx.fillStyle = '#666';
  ctx.font = `bold ${fs * 0.85}px sans-serif`;
  ctx.textBaseline = 'middle';
  ctx.fillText('„Çø„Çπ„ÇØÂêç', 8, hh / 2);

  // Header labels
  ctx.font = `600 ${fs * 0.85}px sans-serif`;
  ctx.fillStyle = '#555';
  let prevYear = null;
  columns.forEach((col, i) => {
    const x = sw + i * colWidth;
    // grid line
    ctx.strokeStyle = '#d0d0d0';
    ctx.lineWidth = 1;
    ctx.beginPath(); ctx.moveTo(x, 0); ctx.lineTo(x, totalH); ctx.stroke();
    let lbl = col.label;
    if (col.year !== prevYear) {
      if (state.timeUnit === 'month') lbl = col.year + '/' + lbl;
      prevYear = col.year;
    }
    ctx.fillStyle = '#555';
    ctx.fillText(lbl, x + 4, hh / 2 + 4);
  });

  // Header bottom line
  ctx.strokeStyle = '#bbb';
  ctx.lineWidth = 2;
  ctx.beginPath(); ctx.moveTo(0, hh); ctx.lineTo(totalW, hh); ctx.stroke();

  // Sidebar border
  ctx.beginPath(); ctx.moveTo(sw, 0); ctx.lineTo(sw, totalH); ctx.stroke();

  // Rows
  visibleRows.forEach((entry, vi) => {
    const row = entry.row;
    const rh = rowHeights[vi];
    const y = hh + rowYOffsets[vi];

    // Row background
    ctx.fillStyle = vi % 2 === 0 ? '#fafbfc' : '#fff';
    ctx.fillRect(0, y, totalW, rh);

    // Row border
    ctx.strokeStyle = '#d0d0d0';
    ctx.lineWidth = 1;
    ctx.beginPath(); ctx.moveTo(0, y + rh); ctx.lineTo(totalW, y + rh); ctx.stroke();

    // Row name
    ctx.fillStyle = '#333';
    ctx.font = `${fs}px sans-serif`;
    ctx.textBaseline = 'middle';
    ctx.fillText(row.name, 8, y + rh / 2, sw - 16);

    // Items
    row.items.forEach(item => {
      if (item.type === 'task') {
        const x1 = sw + getXForDate(item.startDate, columns, colWidth);
        const x2 = sw + getXForDateEnd(item.endDate, columns, colWidth);
        const w = Math.max(x2 - x1, 4);
        const barY = y + (rh - bh) / 2;

        ctx.fillStyle = item.color || COLORS[0];
        roundRect(ctx, x1, barY, w, bh, 4);
        ctx.fill();

        // Shadow
        ctx.shadowColor = 'rgba(0,0,0,.15)';
        ctx.shadowBlur = 3;
        ctx.shadowOffsetY = 1;
        roundRect(ctx, x1, barY, w, bh, 4);
        ctx.fill();
        ctx.shadowColor = 'transparent';
        ctx.shadowBlur = 0;
        ctx.shadowOffsetY = 0;

        if (item.label) {
          const tlp = item.taskLabelPosition || 'inside';
          ctx.font = `${fs * 0.8}px sans-serif`;
          ctx.textBaseline = 'middle';
          const tw = ctx.measureText(item.label).width;
          if (tlp === 'inside') {
            ctx.fillStyle = '#fff';
            if (tw < w - 8) {
              ctx.fillText(item.label, x1 + (w - tw) / 2, barY + bh / 2);
            }
          } else {
            ctx.fillStyle = '#333';
            if (tlp === 'above') {
              ctx.fillText(item.label, x1, barY - 3);
            } else if (tlp === 'below') {
              ctx.fillText(item.label, x1, barY + bh + fs * 0.8 + 1);
            } else if (tlp === 'left') {
              ctx.fillText(item.label, x1 - tw - 4, barY + bh / 2);
            } else if (tlp === 'right') {
              ctx.fillText(item.label, x1 + w + 4, barY + bh / 2);
            }
          }
        }
      } else if (item.type === 'milestone') {
        const x = sw + getXForDateCenter(item.date, columns, colWidth);
        const my = y + rh / 2;
        ctx.fillStyle = '#d32f2f';
        ctx.font = `${fs * 1.3}px sans-serif`;
        ctx.textBaseline = 'middle';
        const markW = ctx.measureText('‚ñΩ').width;
        ctx.fillText('‚ñΩ', x - markW / 2, my);

        if (item.label) {
          ctx.fillStyle = '#333';
          ctx.font = `${fs * 0.8}px sans-serif`;
          if (item.labelPosition === 'before') {
            const lw = ctx.measureText(item.label).width;
            ctx.fillText(item.label, x - markW / 2 - lw - 4, my);
          } else {
            ctx.fillText(item.label, x + markW / 2 + 4, my);
          }
        }
      }
    });
  });

  // Thunder line
  if (state.thunderLine.visible && visibleRows.length > 0) {
    const pts = getThunderPointsForRender();
    const coords = pts.map(p => ({
      x: sw + getXForDateCenter(p.date, columns, colWidth),
      y: hh + rowYOffsets[p.displayIndex] + rowHeights[p.displayIndex] / 2,
      explicit: p.explicit,
      displayIndex: p.displayIndex
    }));

    if (coords.length > 0) {
      const defX = sw + getXForDateCenter(state.thunderLine.defaultDate || fmtDate(new Date()), columns, colWidth);
      ctx.strokeStyle = '#d32f2f';
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.moveTo(defX, hh);
      for (let i = 0; i < coords.length; i++) {
        ctx.lineTo(coords[i].x, coords[i].y);
        const boundaryY = hh + rowYOffsets[coords[i].displayIndex] + rowHeights[coords[i].displayIndex];
        ctx.lineTo(defX, boundaryY);
      }
      ctx.stroke();
    }

    coords.forEach(c => {
      ctx.beginPath();
      ctx.arc(c.x, c.y, c.explicit ? 5 : 3, 0, Math.PI * 2);
      ctx.fillStyle = '#d32f2f';
      ctx.globalAlpha = c.explicit ? 1 : 0.5;
      ctx.fill();
      ctx.globalAlpha = 1;
    });
  }

  return canvas;
}

function roundRect(ctx, x, y, w, h, r) {
  ctx.beginPath();
  ctx.moveTo(x + r, y);
  ctx.lineTo(x + w - r, y);
  ctx.quadraticCurveTo(x + w, y, x + w, y + r);
  ctx.lineTo(x + w, y + h - r);
  ctx.quadraticCurveTo(x + w, y + h, x + w - r, y + h);
  ctx.lineTo(x + r, y + h);
  ctx.quadraticCurveTo(x, y + h, x, y + h - r);
  ctx.lineTo(x, y + r);
  ctx.quadraticCurveTo(x, y, x + r, y);
  ctx.closePath();
}

// ===== Toast =====
function showToast(msg) {
  const toast = document.getElementById('toast');
  toast.textContent = msg;
  toast.style.display = 'block';
  setTimeout(() => { toast.style.display = 'none'; }, 2000);
}

// ===== Init =====
document.addEventListener('DOMContentLoaded', () => {
  document.body.classList.add('edit-mode');
  document.getElementById('thunder-default-date').value = state.thunderLine.defaultDate;
  render();
});

// Keyboard
document.addEventListener('keydown', e => {
  if (e.key === 'Delete' || e.key === 'Backspace') {
    if (appMode === 'edit' && selectedItems.length > 0 && !document.querySelector('.modal-overlay') && document.activeElement.tagName !== 'INPUT' && !document.activeElement.isContentEditable) {
      e.preventDefault();
      deleteSelected();
    }
  }
  if (e.key === 'Escape') {
    hideContextMenu();
    const overlay = document.querySelector('.modal-overlay');
    if (overlay) overlay.remove();
    if (selectedItems.length > 0) { clearSelection(); render(); }
  }
});
</script>
</body>
</html>
