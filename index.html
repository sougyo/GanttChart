<!--
  Copyright 2026 Shogo Matsumoto

  Licensed under the Apache License, Version 2.0 (the "License");
  you may not use this file except in compliance with the License.
  You may obtain a copy of the License at

      http://www.apache.org/licenses/LICENSE-2.0

  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an "AS IS" BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License.
-->
<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Gantt Chart</title>
<style>
:root {
  --font-size: 14px;
  --row-height: 44px;
  --header-height: 36px;
  --sidebar-width: 180px;
  --col-width: 80px;
  --bar-height: 24px;
  --border-color: #d0d0d0;
  --header-bg: #f0f4f8;
  --row-even-bg: #fafbfc;
  --row-odd-bg: #ffffff;
  --accent: #2196F3;
}
* { margin: 0; padding: 0; box-sizing: border-box; }
body { font-family: 'Segoe UI', 'Hiragino Sans', 'Meiryo', sans-serif; font-size: var(--font-size); background: #eef1f5; color: #333; }

#toolbar {
  display: flex; flex-wrap: wrap; align-items: center; gap: 8px;
  padding: 8px 12px; background: #fff; border-bottom: 1px solid #ccc;
  box-shadow: 0 1px 3px rgba(0,0,0,.08); position: sticky; top: 0; z-index: 100;
}
#toolbar label { font-size: 0.85em; color: #555; }
#toolbar select, #toolbar input, #toolbar button {
  font-size: 0.85em; padding: 4px 8px; border: 1px solid #bbb; border-radius: 4px;
}
#toolbar button {
  background: #fff; cursor: pointer; transition: background .15s;
}
#toolbar button:hover { background: #e3f0fc; }
#toolbar button.active { background: var(--accent); color: #fff; border-color: var(--accent); }
.toolbar-sep { width: 1px; height: 24px; background: #ccc; margin: 0 4px; }
.toolbar-group { display: flex; align-items: center; gap: 4px; }

#gantt-wrapper {
  display: grid;
  grid-template-columns: var(--sidebar-width) 1fr;
  grid-template-rows: var(--header-height) 1fr;
  margin: 12px;
  background: #fff;
  border: 1px solid #bbb;
  border-radius: 6px;
  overflow: hidden;
  box-shadow: 0 2px 8px rgba(0,0,0,.07);
  position: relative;
}
#gantt-resize-handle {
  position: absolute; top: 0; width: 8px; height: 100%;
  cursor: col-resize; z-index: 20;
}
#gantt-resize-handle:hover, #gantt-resize-handle.active {
  background: var(--accent); opacity: 0.4; border-radius: 2px;
}
#sidebar-resize-handle {
  position: absolute; top: 0; width: 8px; height: 100%;
  cursor: col-resize; z-index: 20;
  left: calc(var(--sidebar-width) - 4px);
}
#sidebar-resize-handle:hover, #sidebar-resize-handle.active {
  background: var(--accent); opacity: 0.4; border-radius: 2px;
}
#gantt-corner {
  grid-row: 1; grid-column: 1;
  background: var(--header-bg);
  border-right: 2px solid var(--border-color);
  border-bottom: 2px solid var(--border-color);
  display: flex; align-items: center; justify-content: center;
  font-weight: bold; font-size: 0.85em; color: #666;
  outline: none; cursor: text; min-width: 0; overflow: hidden;
  white-space: nowrap; text-overflow: ellipsis; padding: 0 6px;
}
#gantt-corner:focus { background: #e8f0fe; }
#gantt-header-scroll {
  grid-row: 1; grid-column: 2;
  overflow: hidden;
  border-bottom: 2px solid var(--border-color);
  background: var(--header-bg);
}
#gantt-header {
  display: flex; height: 100%;
}
.header-cell {
  flex: 0 0 var(--col-width);
  border-right: 1px solid var(--border-color);
  display: flex; align-items: flex-end;
  padding: 2px 4px; font-size: 0.85em; color: #555; font-weight: 600;
  white-space: nowrap; overflow: hidden;
}
.header-cell.year-start { border-left: 2px solid #999; }
.header-cell.weekend { background: #fff3e0; }
.body-cell.weekend { background: #fff3e0; }

#gantt-sidebar-scroll {
  grid-row: 2; grid-column: 1;
  overflow: hidden;
  border-right: 2px solid var(--border-color);
  position: relative;
}
#gantt-sidebar { }
.sidebar-row {
  border-bottom: 1px solid var(--border-color);
  display: flex; align-items: center;
  padding: 2px 6px; gap: 4px;
  min-height: var(--row-height);
}
.sidebar-row:nth-child(even) { background: var(--row-even-bg); }
.sidebar-name {
  flex: 1; min-width: 0; overflow-wrap: break-word; word-break: break-word;
  white-space: pre-wrap;
  outline: none; font-size: inherit; border: none; background: transparent;
  padding: 2px 4px; border-radius: 3px;
}
.sidebar-name:focus { background: #e8f0fe; }
.sidebar-name[contenteditable="false"] { cursor: default; }
.sidebar-btns { display: flex; gap: 2px; opacity: 0; transition: opacity .15s; }
.sidebar-row:hover .sidebar-btns { opacity: 1; }
.sidebar-btns button {
  width: 20px; height: 20px; border: none; background: transparent;
  cursor: pointer; font-size: 14px; color: #888; border-radius: 3px; line-height: 20px; padding: 0;
}
.sidebar-btns button:hover { background: #ddd; color: #333; }
.sidebar-visibility {
  cursor: pointer; font-size: 14px; flex-shrink: 0; width: 20px; text-align: center;
  user-select: none; color: #888; opacity: 0.7;
}
.sidebar-visibility:hover { opacity: 1; }
.sidebar-row.row-hidden .sidebar-name { color: #bbb; text-decoration: line-through; }
.sidebar-drag-handle {
  cursor: grab; color: #bbb; font-size: 14px; padding: 0 2px;
  user-select: none; flex-shrink: 0;
}
.sidebar-drag-handle:hover { color: #666; }
.sidebar-row.drag-over-above { box-shadow: inset 0 3px 0 0 var(--accent); }
.sidebar-row.drag-over-below { box-shadow: inset 0 -3px 0 0 var(--accent); }
.sidebar-row.dragging { opacity: 0.4; }

#gantt-body-scroll {
  grid-row: 2; grid-column: 2;
  overflow: auto;
  position: relative;
}
#gantt-body {
  position: relative;
}
.body-row {
  display: flex;
  border-bottom: 1px solid var(--border-color);
}
.body-row:nth-child(even) { background: var(--row-even-bg); }
.body-cell {
  flex: 0 0 var(--col-width);
  border-right: 1px solid #e8e8e8;
  height: 100%;
}
.body-cell.year-start { border-left: 2px solid #bbb; }

#items-layer {
  position: absolute; top: 0; left: 0; pointer-events: none;
}
.gantt-item { position: absolute; pointer-events: auto; cursor: pointer; }
.gantt-task {
  height: var(--bar-height); border-radius: 4px;
  display: flex; align-items: center; justify-content: center;
  font-size: 0.8em; color: #fff; overflow: hidden;
  white-space: nowrap; text-overflow: ellipsis; padding: 0 6px;
  border: 2px solid transparent;
  transition: box-shadow .1s;
}
.gantt-task:hover { box-shadow: 0 2px 6px rgba(0,0,0,.25); }
.gantt-task.selected { border-color: var(--accent); box-shadow: 0 0 0 2px rgba(33,150,243,.3); }
.gantt-task .resize-handle {
  position: absolute; top: 0; width: 6px; height: 100%; cursor: ew-resize;
  opacity: 0;
}
.gantt-task .resize-handle.left { left: -2px; }
.gantt-task .resize-handle.right { right: -2px; }
.edit-mode .gantt-task:hover .resize-handle { opacity: 1; background: rgba(0,0,0,.15); }

.gantt-milestone {
  display: flex; align-items: center; gap: 2px;
  font-size: 0.8em; white-space: nowrap;
  border: 2px solid transparent; border-radius: 3px; padding: 1px 3px;
}
.gantt-milestone.selected { border-color: var(--accent); background: rgba(33,150,243,.08); }

.task-label { pointer-events: none; overflow: hidden; text-overflow: ellipsis; }
.task-label-outside {
  position: absolute; pointer-events: none; white-space: nowrap;
  font-size: inherit; color: #333;
}
.task-label-outside.pos-above { bottom: 100%; left: 0; margin-bottom: 1px; }
.task-label-outside.pos-below { top: 100%; left: 0; margin-top: 1px; }
.task-label-outside.pos-left { right: 100%; top: 50%; transform: translateY(-50%); margin-right: 4px; }
.task-label-outside.pos-right { left: 100%; top: 50%; transform: translateY(-50%); margin-left: 4px; }
.inline-edit {
  background: rgba(255,255,255,.95); color: #333; border: 1px solid var(--accent);
  border-radius: 3px; padding: 1px 4px; font-size: inherit;
  outline: none; min-width: 40px; max-width: 100%;
  pointer-events: auto; position: relative; z-index: 10;
}
.gantt-task .inline-edit { max-width: calc(100% - 12px); }
.gantt-milestone .inline-edit { min-width: 60px; }
.milestone-mark { font-size: 1.3em; color: #d32f2f; line-height: 1; }
.milestone-label { color: #333; }

#thunder-svg {
  position: absolute; top: 0; left: 0; pointer-events: none; z-index: 5;
}
.thunder-dot {
  pointer-events: auto; cursor: grab;
}
.thunder-dot:active { cursor: grabbing; }

/* Context Menu */
#context-menu {
  position: fixed; background: #fff; border: 1px solid #ccc; border-radius: 6px;
  box-shadow: 0 4px 16px rgba(0,0,0,.15); z-index: 200; min-width: 160px;
  padding: 4px 0; display: none;
}
#context-menu .menu-item {
  padding: 6px 16px; cursor: pointer; font-size: 0.9em;
}
#context-menu .menu-item:hover { background: #e8f0fe; }
#context-menu .menu-sep { height: 1px; background: #e0e0e0; margin: 4px 0; }

/* Modal */
.modal-overlay {
  position: fixed; top: 0; left: 0; width: 100%; height: 100%;
  background: rgba(0,0,0,.35); z-index: 300;
  display: flex; align-items: center; justify-content: center;
}
.modal {
  background: #fff; border-radius: 8px; padding: 20px; min-width: 320px;
  box-shadow: 0 8px 32px rgba(0,0,0,.2);
}
.modal h3 { margin-bottom: 12px; font-size: 1.1em; }
.modal .field { margin-bottom: 10px; }
.modal .field label { display: block; font-size: 0.85em; color: #555; margin-bottom: 3px; }
.modal .field input, .modal .field select {
  width: 100%; padding: 6px 8px; border: 1px solid #bbb; border-radius: 4px; font-size: 0.95em;
}
.modal .field .color-options { display: flex; gap: 6px; flex-wrap: wrap; }
.modal .field .color-opt {
  width: 28px; height: 28px; border-radius: 50%; cursor: pointer;
  border: 3px solid transparent; transition: border-color .1s;
}
.modal .field .color-opt.selected { border-color: #333; }
.modal .modal-btns { display: flex; justify-content: flex-end; gap: 8px; margin-top: 16px; }
.modal .modal-btns button {
  padding: 6px 18px; border: 1px solid #bbb; border-radius: 4px;
  cursor: pointer; font-size: 0.9em;
}
.modal .modal-btns .btn-primary { background: var(--accent); color: #fff; border-color: var(--accent); }

/* View mode styles */
.view-mode #gantt-wrapper { border-radius: 0; margin: 0; }
.view-mode .gantt-task { border-radius: 5px; box-shadow: 0 1px 4px rgba(0,0,0,.15); }
.view-mode .body-cell { border-right-color: #f0f0f0; }
.view-mode .sidebar-btns { display: none !important; }

/* Toast */
#toast {
  position: fixed; bottom: 20px; left: 50%; transform: translateX(-50%);
  background: #333; color: #fff; padding: 10px 24px; border-radius: 6px;
  font-size: 0.9em; z-index: 400; display: none; box-shadow: 0 4px 12px rgba(0,0,0,.3);
}
#drag-tooltip {
  position: fixed; pointer-events: none; z-index: 500;
  background: rgba(0,0,0,.8); color: #fff; padding: 3px 8px; border-radius: 4px;
  font-size: 12px; white-space: nowrap; display: none;
  transform: translate(-50%, -130%);
}
</style>
</head>
<body>

<div id="toolbar">
  <div class="toolbar-group">
    <button id="btn-edit-mode" class="active" onclick="setMode('edit')"></button>
    <button id="btn-view-mode" onclick="setMode('view')"></button>
  </div>
  <div class="toolbar-sep"></div>
  <div class="toolbar-group">
    <label id="lbl-unit"></label>
    <select id="sel-unit" onchange="changeUnit(this.value)">
      <option value="month" selected id="opt-month"></option>
      <option value="week" id="opt-week"></option>
      <option value="day" id="opt-day"></option>
    </select>
  </div>
  <div class="toolbar-sep"></div>
  <div class="toolbar-group">
    <label id="lbl-font"></label>
    <button onclick="changeFontSize(-1)">A-</button>
    <button onclick="changeFontSize(1)">A+</button>
  </div>
  <div class="toolbar-sep"></div>
  <div class="toolbar-group" id="edit-controls">
    <button id="btn-add-col-start" onclick="addColumnStart()"></button>
    <button id="btn-add-col-end" onclick="addColumnEnd()"></button>
    <button id="btn-rm-col-start" onclick="removeColumnStart()"></button>
    <button id="btn-rm-col-end" onclick="removeColumnEnd()"></button>
    <button id="btn-add-row" onclick="addRow()"></button>
  </div>
  <div class="toolbar-group" id="thunder-controls">
    <div class="toolbar-sep"></div>
    <label><input type="checkbox" id="chk-thunder" checked onchange="toggleThunder(this.checked)"> <span id="lbl-thunder"></span></label>
    <label id="lbl-base-date"></label>
    <input type="date" id="thunder-default-date" onchange="changeThunderDefault(this.value)">
  </div>
  <div class="toolbar-group" id="view-controls" style="display:none;">
    <label id="lbl-range"></label>
    <input type="date" id="view-start" onchange="applyViewRange()">
    <span>~</span>
    <input type="date" id="view-end" onchange="applyViewRange()">
    <button id="btn-all-range" onclick="clearViewRange()"></button>
    <div class="toolbar-sep"></div>
    <button id="btn-copy-image" onclick="copyAsImage()"></button>
  </div>
  <div class="toolbar-sep"></div>
  <div class="toolbar-group">
    <button id="btn-export" onclick="exportJSON()"></button>
    <button id="btn-import" onclick="importJSON()"></button>
  </div>
  <div class="toolbar-sep"></div>
  <div class="toolbar-group">
    <select id="sel-lang" onchange="changeLang(this.value)">
      <option value="en">EN</option>
      <option value="ja">JA</option>
    </select>
  </div>
</div>

<div id="gantt-wrapper">
  <div id="sidebar-resize-handle"></div>
  <div id="gantt-corner" contenteditable="true">Task</div>
  <div id="gantt-header-scroll"><div id="gantt-header"></div></div>
  <div id="gantt-sidebar-scroll"><div id="gantt-sidebar"></div></div>
  <div id="gantt-body-scroll">
    <div id="gantt-body">
      <div id="grid-layer"></div>
      <div id="items-layer"></div>
      <svg id="thunder-svg"></svg>
      <div id="gantt-resize-handle"></div>
    </div>
  </div>
</div>

<div id="context-menu"></div>
<div id="toast"></div>
<div id="drag-tooltip"></div>
<input type="file" id="file-input" accept=".json" style="display:none" onchange="handleFileImport(event)">

<script>
// ===== i18n =====
const I18N = {
  en: {
    title: 'Gantt Chart',
    taskName: 'Task',
    edit: 'Edit',
    view: 'View',
    unit: 'Unit:',
    month: 'Month',
    week: 'Week',
    day: 'Day',
    font: 'Font:',
    addColStart: '\u2190Col',
    addColEnd: 'Col\u2192',
    rmColStart: '\u2190Del',
    rmColEnd: 'Del\u2192',
    addRow: 'Add Row',
    thunderLine: 'Thunder Line',
    baseDate: 'Base:',
    range: 'Range:',
    allRange: 'All',
    copyImage: 'Copy Image',
    export: 'Export',
    import: 'Import',
    cancel: 'Cancel',
    ok: 'OK',
    label: 'Label',
    startDate: 'Start',
    endDate: 'End',
    color: 'Color',
    labelPos: 'Label Position',
    posInside: 'Inside',
    posAbove: 'Above',
    posBelow: 'Below',
    posLeft: 'Left',
    posRight: 'Right',
    posBefore: 'Before',
    posAfter: 'After',
    date: 'Date',
    addTask: 'Add Task',
    addMilestone: 'Add Milestone',
    editTask: 'Edit Task',
    editMilestone: 'Edit Milestone',
    addProgress: 'Add Progress Point',
    deleteSelected: 'Delete Selected',
    deleteRow: 'Delete Row',
    addRowAbove: 'Add Row Above',
    deleteItem: 'Delete',
    editItem: 'Edit Task\u2026',
    editMilestoneItem: 'Edit Milestone\u2026',
    deleteProgress: 'Reset Progress (use base date)',
    visibleInView: 'Visible in View mode',
    hiddenInView: 'Hidden in View mode',
    dragToReorder: 'Drag to reorder',
    unnamed: '(Unnamed)',
    newTask: 'New Task',
    exported: 'Exported',
    imported: 'Imported',
    imageCopied: 'Image copied to clipboard',
    imageDownloaded: 'Image downloaded',
    invalidFile: 'Invalid file format.',
    jsonError: 'Failed to load JSON: ',
  },
  ja: {
    title: '\u30AC\u30F3\u30C8\u30C1\u30E3\u30FC\u30C8',
    taskName: '\u30BF\u30B9\u30AF\u540D',
    edit: '\u7DE8\u96C6',
    view: '\u8868\u793A',
    unit: '\u5358\u4F4D:',
    month: '\u6708',
    week: '\u9031',
    day: '\u65E5',
    font: '\u6587\u5B57:',
    addColStart: '\u2190\u5217\u8FFD\u52A0',
    addColEnd: '\u5217\u8FFD\u52A0\u2192',
    rmColStart: '\u2190\u5217\u524A\u9664',
    rmColEnd: '\u5217\u524A\u9664\u2192',
    addRow: '\u884C\u8FFD\u52A0',
    thunderLine: '\u30A4\u30CA\u30BA\u30DE\u7DDA',
    baseDate: '\u57FA\u6E96\u65E5:',
    range: '\u671F\u9593:',
    allRange: '\u5168\u671F\u9593',
    copyImage: '\u753B\u50CF\u30B3\u30D4\u30FC',
    export: '\u30A8\u30AF\u30B9\u30DD\u30FC\u30C8',
    import: '\u30A4\u30F3\u30DD\u30FC\u30C8',
    cancel: '\u30AD\u30E3\u30F3\u30BB\u30EB',
    ok: 'OK',
    label: '\u30E9\u30D9\u30EB',
    startDate: '\u958B\u59CB\u65E5',
    endDate: '\u7D42\u4E86\u65E5',
    color: '\u8272',
    labelPos: '\u30E9\u30D9\u30EB\u4F4D\u7F6E',
    posInside: '\u4E2D',
    posAbove: '\u4E0A',
    posBelow: '\u4E0B',
    posLeft: '\u5DE6',
    posRight: '\u53F3',
    posBefore: '\u524D',
    posAfter: '\u5F8C',
    date: '\u65E5\u4ED8',
    addTask: '\u4F5C\u696D\u3092\u8FFD\u52A0',
    addMilestone: '\u30A4\u30D9\u30F3\u30C8\u3092\u8FFD\u52A0',
    editTask: '\u4F5C\u696D\u3092\u7DE8\u96C6',
    editMilestone: '\u30A4\u30D9\u30F3\u30C8\u3092\u7DE8\u96C6',
    addProgress: '\u9032\u6357\u4F4D\u7F6E\u3092\u8FFD\u52A0',
    deleteSelected: '\u9078\u629E\u9805\u76EE\u3092\u524A\u9664',
    deleteRow: '\u884C\u524A\u9664',
    addRowAbove: '\u4E0A\u306B\u884C\u8FFD\u52A0',
    deleteItem: '\u524A\u9664',
    editItem: '\u4F5C\u696D\u3092\u7DE8\u96C6\u2026',
    editMilestoneItem: '\u30A4\u30D9\u30F3\u30C8\u3092\u7DE8\u96C6\u2026',
    deleteProgress: '\u9032\u6357\u4F4D\u7F6E\u3092\u524A\u9664\uFF08\u57FA\u6E96\u65E5\u306B\u623B\u3059\uFF09',
    visibleInView: '\u8868\u793A\u30E2\u30FC\u30C9\u3067\u8868\u793A',
    hiddenInView: '\u8868\u793A\u30E2\u30FC\u30C9\u3067\u975E\u8868\u793A',
    dragToReorder: '\u30C9\u30E9\u30C3\u30B0\u3067\u4E26\u3079\u66FF\u3048',
    unnamed: '(\u672A\u8A2D\u5B9A)',
    newTask: '\u65B0\u898F\u4F5C\u696D',
    exported: '\u30A8\u30AF\u30B9\u30DD\u30FC\u30C8\u3057\u307E\u3057\u305F',
    imported: '\u30A4\u30F3\u30DD\u30FC\u30C8\u3057\u307E\u3057\u305F',
    imageCopied: '\u753B\u50CF\u3092\u30AF\u30EA\u30C3\u30D7\u30DC\u30FC\u30C9\u306B\u30B3\u30D4\u30FC\u3057\u307E\u3057\u305F',
    imageDownloaded: '\u753B\u50CF\u3092\u30C0\u30A6\u30F3\u30ED\u30FC\u30C9\u3057\u307E\u3057\u305F',
    invalidFile: '\u7121\u52B9\u306A\u30D5\u30A1\u30A4\u30EB\u5F62\u5F0F\u3067\u3059\u3002',
    jsonError: 'JSON\u306E\u8AAD\u307F\u8FBC\u307F\u306B\u5931\u6557\u3057\u307E\u3057\u305F: ',
  }
};

let currentLang = 'en';

function t(key) {
  return (I18N[currentLang] && I18N[currentLang][key]) || I18N.en[key] || key;
}

function updateUIText() {
  document.title = t('title');
  document.documentElement.lang = currentLang;
  document.getElementById('btn-edit-mode').textContent = t('edit');
  document.getElementById('btn-view-mode').textContent = t('view');
  document.getElementById('lbl-unit').textContent = t('unit');
  document.getElementById('opt-month').textContent = t('month');
  document.getElementById('opt-week').textContent = t('week');
  document.getElementById('opt-day').textContent = t('day');
  document.getElementById('lbl-font').textContent = t('font');
  document.getElementById('btn-add-col-start').textContent = t('addColStart');
  document.getElementById('btn-add-col-end').textContent = t('addColEnd');
  document.getElementById('btn-rm-col-start').textContent = t('rmColStart');
  document.getElementById('btn-rm-col-end').textContent = t('rmColEnd');
  document.getElementById('btn-add-row').textContent = t('addRow');
  document.getElementById('lbl-thunder').textContent = t('thunderLine');
  document.getElementById('lbl-base-date').textContent = t('baseDate');
  document.getElementById('lbl-range').textContent = t('range');
  document.getElementById('btn-all-range').textContent = t('allRange');
  document.getElementById('btn-copy-image').textContent = t('copyImage');
  document.getElementById('btn-export').textContent = t('export');
  document.getElementById('btn-import').textContent = t('import');
  const corner = document.getElementById('gantt-corner');
  corner.textContent = state.cornerLabel || t('taskName');
}

function changeLang(lang) {
  currentLang = lang;
  state.lang = lang;
  document.getElementById('sel-lang').value = lang;
  updateUIText();
  render();
}

// ===== State =====
const _now = new Date();
const _initStart = new Date(_now.getFullYear(), _now.getMonth() - 1, 1);
const _initEnd = new Date(_now.getFullYear(), _now.getMonth() + 2, 0);
let state = {
  lang: 'en',
  timeUnit: 'month',
  startDate: fmtDate(_initStart),
  endDate: fmtDate(_initEnd),
  fontSize: 14,
  cornerLabel: '',
  rows: [
    { name: 'Task 1', items: [] },
    { name: 'Task 2', items: [] },
    { name: 'Task 3', items: [] }
  ],
  thunderLine: { visible: true, points: [], defaultDate: fmtDate(new Date()) }
};

let appMode = 'edit'; // edit | view
let viewRange = null; // {start, end}
let selectedItems = []; // [{rowIndex, itemIndex}]
let columns = [];
let colWidth = 80;
let customColWidth = null; // user-set column width via drag resize
let isDragging = false;
let dragData = null;

const COLORS = ['#4CAF50','#2196F3','#FF9800','#9C27B0','#F44336','#00BCD4','#795548','#607D8B','#E91E63','#3F51B5'];

// ===== Date Utils =====
function parseDate(s) { const p = s.split('-'); return new Date(+p[0], +p[1]-1, +p[2]); }
function fmtDate(d) { return `${d.getFullYear()}-${String(d.getMonth()+1).padStart(2,'0')}-${String(d.getDate()).padStart(2,'0')}`; }
function addDays(d, n) { const r = new Date(d); r.setDate(r.getDate()+n); return r; }
function daysBetween(a, b) { return Math.round((b.getTime()-a.getTime())/86400000); }
function monthStart(d) { return new Date(d.getFullYear(), d.getMonth(), 1); }
function monthEnd(d) { return new Date(d.getFullYear(), d.getMonth()+1, 0); }
function weekStart(d) { const r = new Date(d); const day = r.getDay(); r.setDate(r.getDate() - (day === 0 ? 6 : day - 1)); return r; }
function minDate(a,b) { return a < b ? a : b; }
function maxDate(a,b) { return a > b ? a : b; }

// ===== Column Generation =====
function generateColumns(start, end, unit) {
  const cols = [];
  const sd = parseDate(start), ed = parseDate(end);
  if (unit === 'month') {
    let cur = monthStart(sd);
    while (cur <= ed) {
      const mEnd = monthEnd(cur);
      cols.push({ start: new Date(cur), end: mEnd, label: String(cur.getMonth()+1), year: cur.getFullYear() });
      cur = new Date(cur.getFullYear(), cur.getMonth()+1, 1);
    }
  } else if (unit === 'week') {
    let cur = weekStart(sd);
    while (cur <= ed) {
      const wEnd = addDays(cur, 6);
      cols.push({ start: new Date(cur), end: wEnd, label: `${cur.getMonth()+1}/${cur.getDate()}`, year: cur.getFullYear() });
      cur = addDays(cur, 7);
    }
  } else {
    let cur = new Date(sd);
    while (cur <= ed) {
      const dow = cur.getDay();
      cols.push({ start: new Date(cur), end: new Date(cur), label: `${cur.getMonth()+1}/${cur.getDate()}`, year: cur.getFullYear(), weekend: dow === 0 || dow === 6 });
      cur = addDays(cur, 1);
    }
  }
  return cols;
}

// Returns the LEFT edge position of the given date's slot within its column
function getXForDate(date, cols, cw) {
  const d = (typeof date === 'string') ? parseDate(date) : date;
  for (let i = 0; i < cols.length; i++) {
    if (d >= cols[i].start && d <= cols[i].end) {
      const totalDays = daysBetween(cols[i].start, cols[i].end) + 1;
      const off = daysBetween(cols[i].start, d);
      return i * cw + (off / totalDays) * cw;
    }
  }
  if (d < cols[0].start) return 0;
  return cols.length * cw;
}

// Returns the RIGHT edge position of the given date's slot
function getXForDateEnd(date, cols, cw) {
  const d = (typeof date === 'string') ? parseDate(date) : date;
  for (let i = 0; i < cols.length; i++) {
    if (d >= cols[i].start && d <= cols[i].end) {
      const totalDays = daysBetween(cols[i].start, cols[i].end) + 1;
      const off = daysBetween(cols[i].start, d);
      return i * cw + ((off + 1) / totalDays) * cw;
    }
  }
  if (d < cols[0].start) return 0;
  return cols.length * cw;
}

// Returns the CENTER position of the given date's slot (for milestones, thunder points)
function getXForDateCenter(date, cols, cw) {
  return (getXForDate(date, cols, cw) + getXForDateEnd(date, cols, cw)) / 2;
}

function getDateForX(x, cols, cw) {
  const ci = Math.floor(x / cw);
  if (ci < 0) return new Date(cols[0].start);
  if (ci >= cols.length) return new Date(cols[cols.length-1].end);
  const col = cols[ci];
  const off = x - ci * cw;
  const totalDays = daysBetween(col.start, col.end) + 1;
  const dayOff = Math.floor((off / cw) * totalDays);
  return addDays(col.start, Math.max(0, Math.min(dayOff, totalDays - 1)));
}

// ===== Rendering =====
function render() {
  const sd = viewRange ? viewRange.start : state.startDate;
  const ed = viewRange ? viewRange.end : state.endDate;
  columns = generateColumns(sd, ed, state.timeUnit);

  // Column width: use custom value if set, otherwise default
  if (customColWidth !== null) {
    colWidth = customColWidth;
  } else {
    const bodyScroll = document.getElementById('gantt-body-scroll');
    if (appMode === 'view' && viewRange) {
      const avail = bodyScroll.clientWidth || (window.innerWidth - parseInt(getComputedStyle(document.documentElement).getPropertyValue('--sidebar-width')) - 30);
      colWidth = Math.max(30, Math.floor(avail / columns.length));
    } else {
      colWidth = state.timeUnit === 'day' ? 36 : (state.timeUnit === 'week' ? 52 : 80);
    }
  }

  document.documentElement.style.setProperty('--col-width', colWidth + 'px');
  document.documentElement.style.setProperty('--font-size', state.fontSize + 'px');

  visibleRows = getVisibleRows();
  computeRowLayout();
  renderHeader();
  renderSidebar();
  measureSidebarRowHeights();
  renderBody();
  renderItems();
  renderThunderLine();
}

const BASE_ROW_HEIGHT = 44;
let rowHeights = []; // per visible row
let rowYOffsets = []; // cumulative Y for each visible row
let totalBodyHeight = 0;

function computeRowLayout() {
  const labelExtra = Math.ceil(state.fontSize * 0.8) + 4;
  rowHeights = [];
  rowYOffsets = [];
  let y = 0;
  visibleRows.forEach((entry, vi) => {
    let hasAbove = false, hasBelow = false;
    entry.row.items.forEach(item => {
      if (item.type === 'task') {
        const pos = item.taskLabelPosition || 'inside';
        if (pos === 'above') hasAbove = true;
        if (pos === 'below') hasBelow = true;
      }
    });
    const h = BASE_ROW_HEIGHT + (hasAbove ? labelExtra : 0) + (hasBelow ? labelExtra : 0);
    rowHeights.push(h);
    rowYOffsets.push(y);
    y += h;
  });
  totalBodyHeight = y;
}

function getVisibleRowIndexForY(y) {
  for (let i = 0; i < visibleRows.length; i++) {
    if (y < rowYOffsets[i] + rowHeights[i]) return i;
  }
  return visibleRows.length - 1;
}

// Returns array of {row, originalIndex} for rows to display
function getVisibleRows() {
  if (appMode === 'edit') {
    return state.rows.map((r, i) => ({ row: r, originalIndex: i }));
  }
  return state.rows
    .map((r, i) => ({ row: r, originalIndex: i }))
    .filter(entry => entry.row.visible !== false);
}

let visibleRows = [];

function renderHeader() {
  const hdr = document.getElementById('gantt-header');
  hdr.innerHTML = '';
  hdr.style.width = (columns.length * colWidth) + 'px';
  let prevYear = null;
  columns.forEach((col, i) => {
    const cell = document.createElement('div');
    cell.className = 'header-cell';
    if (col.year !== prevYear && i > 0) cell.classList.add('year-start');
    if (col.weekend) cell.classList.add('weekend');
    cell.style.flexBasis = colWidth + 'px';
    cell.style.minWidth = colWidth + 'px';
    let lbl = col.label;
    if (col.year !== prevYear) {
      if (state.timeUnit === 'month') lbl = col.year + '/' + lbl;
      prevYear = col.year;
    }
    cell.textContent = lbl;
    hdr.appendChild(cell);
  });
}

function measureSidebarRowHeights() {
  const sb = document.getElementById('gantt-sidebar');
  const sidebarRows = sb.querySelectorAll('.sidebar-row');
  let y = 0;
  sidebarRows.forEach((el, i) => {
    const naturalH = el.offsetHeight;
    if (naturalH > rowHeights[i]) {
      rowHeights[i] = naturalH;
    }
    el.style.height = rowHeights[i] + 'px';
    rowYOffsets[i] = y;
    y += rowHeights[i];
  });
  totalBodyHeight = y;
}

function renderSidebar() {
  const sb = document.getElementById('gantt-sidebar');
  sb.innerHTML = '';

  if (appMode === 'edit') {
    // Edit mode: show all rows with visibility toggle
    state.rows.forEach((row, ri) => {
      // In edit mode visibleRows = all rows, so vi === ri
      const div = document.createElement('div');
      div.className = 'sidebar-row';
      div.style.minHeight = rowHeights[ri] + 'px';
      div.dataset.rowIndex = ri;

      const vis = document.createElement('span');
      vis.className = 'sidebar-visibility';
      vis.textContent = row.visible === false ? 'ðŸ”‡' : 'ðŸ‘';
      vis.title = row.visible === false ? t('hiddenInView') : t('visibleInView');
      vis.onclick = () => {
        state.rows[ri].visible = !(row.visible !== false);
        render();
      };
      div.appendChild(vis);

      const handle = document.createElement('span');
      handle.className = 'sidebar-drag-handle';
      handle.textContent = 'â˜°';
      handle.title = t('dragToReorder');
      handle.addEventListener('mousedown', e => startRowDrag(e, ri));
      div.appendChild(handle);

      if (row.visible === false) div.classList.add('row-hidden');

      const nameEl = document.createElement('span');
      nameEl.className = 'sidebar-name';
      nameEl.textContent = row.name;
      nameEl.contentEditable = true;
      nameEl.addEventListener('blur', () => { state.rows[ri].name = nameEl.innerText.trim() || t('unnamed'); render(); });
      nameEl.addEventListener('keydown', e => {
        if (e.key === 'Enter' && !e.shiftKey) { e.preventDefault(); nameEl.blur(); }
      });
      div.appendChild(nameEl);

      const btns = document.createElement('div');
      btns.className = 'sidebar-btns';
      const btnDel = document.createElement('button');
      btnDel.textContent = 'Ã—';
      btnDel.title = t('deleteRow');
      btnDel.onclick = () => { if(state.rows.length>1){state.rows.splice(ri,1);selectedItems=[];render();} };
      const btnUp = document.createElement('button');
      btnUp.textContent = 'â†‘';
      btnUp.title = t('addRowAbove');
      btnUp.onclick = () => { state.rows.splice(ri,0,{name:t('newTask'),items:[]});render(); };
      btns.appendChild(btnUp);
      btns.appendChild(btnDel);
      div.appendChild(btns);

      sb.appendChild(div);
    });
  } else {
    // View mode: show only visible rows
    visibleRows.forEach((entry, vi) => {
      const div = document.createElement('div');
      div.className = 'sidebar-row';
      div.style.minHeight = rowHeights[vi] + 'px';
      const nameEl = document.createElement('span');
      nameEl.className = 'sidebar-name';
      nameEl.textContent = entry.row.name;
      nameEl.contentEditable = false;
      div.appendChild(nameEl);
      sb.appendChild(div);
    });
  }
}

// ===== Row Drag & Drop =====
function startRowDrag(e, fromIndex) {
  e.preventDefault();
  e.stopPropagation();
  const sb = document.getElementById('gantt-sidebar');
  const rows = sb.querySelectorAll('.sidebar-row');
  let targetIndex = fromIndex;

  rows[fromIndex].classList.add('dragging');

  function onMove(ev) {
    // Clear all indicators
    rows.forEach(r => { r.classList.remove('drag-over-above', 'drag-over-below'); });

    // Find which row the mouse is over
    const sbRect = sb.getBoundingClientRect();
    const sidebarScroll = document.getElementById('gantt-sidebar-scroll');
    const y = ev.clientY - sbRect.top + sidebarScroll.scrollTop;
    let hoverIndex = getVisibleRowIndexForY(y);
    hoverIndex = Math.max(0, Math.min(hoverIndex, state.rows.length - 1));

    if (hoverIndex === fromIndex) {
      targetIndex = fromIndex;
      return;
    }

    // Show indicator
    if (hoverIndex < fromIndex) {
      // Moving up: drop above the hovered row
      rows[hoverIndex].classList.add('drag-over-above');
      targetIndex = hoverIndex;
    } else {
      // Moving down: drop below the hovered row
      rows[hoverIndex].classList.add('drag-over-below');
      targetIndex = hoverIndex;
    }
  }

  function onUp() {
    document.removeEventListener('mousemove', onMove);
    document.removeEventListener('mouseup', onUp);
    rows.forEach(r => { r.classList.remove('dragging', 'drag-over-above', 'drag-over-below'); });

    if (targetIndex !== fromIndex) {
      moveRow(fromIndex, targetIndex);
    }
  }

  document.addEventListener('mousemove', onMove);
  document.addEventListener('mouseup', onUp);
}

function moveRow(from, to) {
  // Move the row in state.rows
  const row = state.rows.splice(from, 1)[0];
  state.rows.splice(to, 0, row);

  // Update thunder line point indices
  state.thunderLine.points.forEach(p => {
    if (p.rowIndex === from) {
      p.rowIndex = to;
    } else if (from < to) {
      // Moved down: rows between (from, to] shift up by 1
      if (p.rowIndex > from && p.rowIndex <= to) p.rowIndex--;
    } else {
      // Moved up: rows between [to, from) shift down by 1
      if (p.rowIndex >= to && p.rowIndex < from) p.rowIndex++;
    }
  });

  // Update selected items indices
  selectedItems = selectedItems.map(s => {
    let newRi = s.rowIndex;
    if (s.rowIndex === from) {
      newRi = to;
    } else if (from < to) {
      if (s.rowIndex > from && s.rowIndex <= to) newRi--;
    } else {
      if (s.rowIndex >= to && s.rowIndex < from) newRi++;
    }
    return { rowIndex: newRi, itemIndex: s.itemIndex };
  });

  render();
}

function renderBody() {
  const grid = document.getElementById('grid-layer');
  grid.innerHTML = '';
  const totalW = columns.length * colWidth;
  const body = document.getElementById('gantt-body');
  body.style.width = totalW + 'px';
  body.style.height = totalBodyHeight + 'px';

  // Position resize handle at right edge of last column
  const resizeHandle = document.getElementById('gantt-resize-handle');
  resizeHandle.style.left = (totalW - 4) + 'px';
  let prevYear = null;
  visibleRows.forEach((entry, vi) => {
    const rowDiv = document.createElement('div');
    rowDiv.className = 'body-row';
    rowDiv.style.height = rowHeights[vi] + 'px';
    prevYear = null;
    columns.forEach((col, ci) => {
      const cell = document.createElement('div');
      cell.className = 'body-cell';
      cell.style.flexBasis = colWidth + 'px';
      cell.style.minWidth = colWidth + 'px';
      if (col.year !== prevYear && ci > 0) cell.classList.add('year-start');
      if (col.weekend) cell.classList.add('weekend');
      prevYear = col.year;
      rowDiv.appendChild(cell);
    });
    grid.appendChild(rowDiv);
  });
}

function renderItems() {
  const layer = document.getElementById('items-layer');
  layer.innerHTML = '';
  const bh = parseInt(getComputedStyle(document.documentElement).getPropertyValue('--bar-height'));

  visibleRows.forEach((entry, vi) => {
    const ri = entry.originalIndex;
    const rh = rowHeights[vi];
    const ry = rowYOffsets[vi];
    entry.row.items.forEach((item, ii) => {
      if (item.type === 'task') {
        renderTask(layer, item, ri, ii, rh, bh, ry);
      } else if (item.type === 'milestone') {
        renderMilestone(layer, item, ri, ii, rh, ry);
      }
    });
  });
}

function renderTask(layer, item, ri, ii, rh, bh, ry) {
  const x1 = getXForDate(item.startDate, columns, colWidth);
  const x2 = getXForDateEnd(item.endDate, columns, colWidth);
  if (x2 < 0 || x1 > columns.length * colWidth) return;
  const w = Math.max(x2 - x1, 6);
  const top = ry + (rh - bh) / 2;

  const el = document.createElement('div');
  el.className = 'gantt-item gantt-task';
  if (isSelected(ri, ii)) el.classList.add('selected');
  el.style.left = x1 + 'px';
  el.style.top = top + 'px';
  el.style.width = w + 'px';
  el.style.background = item.color || COLORS[0];
  const lblPos = item.taskLabelPosition || 'inside';
  if (lblPos !== 'inside') el.style.overflow = 'visible';
  let taskLabel;
  if (lblPos === 'inside') {
    taskLabel = document.createElement('span');
    taskLabel.className = 'task-label';
    taskLabel.textContent = item.label || '';
    el.appendChild(taskLabel);
  } else {
    taskLabel = document.createElement('span');
    taskLabel.className = 'task-label-outside pos-' + lblPos;
    taskLabel.textContent = item.label || '';
    el.appendChild(taskLabel);
  }
  el.title = `${item.label || ''}\n${item.startDate} ã€œ ${item.endDate}`;

  if (appMode === 'edit') {
    const lHandle = document.createElement('div');
    lHandle.className = 'resize-handle left';
    lHandle.addEventListener('mousedown', e => startResize(e, ri, ii, 'left'));
    el.appendChild(lHandle);
    const rHandle = document.createElement('div');
    rHandle.className = 'resize-handle right';
    rHandle.addEventListener('mousedown', e => startResize(e, ri, ii, 'right'));
    el.appendChild(rHandle);

    el.addEventListener('mousedown', e => {
      if (e.target.classList.contains('resize-handle')) return;
      if (el.querySelector('.inline-edit')) return;
      onItemMouseDown(e, ri, ii);
    });
    el.addEventListener('dblclick', e => {
      e.stopPropagation();
      startInlineEdit(el, taskLabel, text => {
        state.rows[ri].items[ii].label = text;
        render();
      });
    });
    el.addEventListener('contextmenu', e => {
      e.preventDefault(); e.stopPropagation();
      showContextMenu(e.clientX, e.clientY, [
        { label: t('editItem'), action: () => editItemDialog(ri, ii) },
        { label: t('deleteItem'), action: () => { state.rows[ri].items.splice(ii, 1); selectedItems = []; render(); } }
      ]);
    });
  }
  layer.appendChild(el);
}

function renderMilestone(layer, item, ri, ii, rh, ry) {
  const x = getXForDateCenter(item.date, columns, colWidth);
  if (x < 0 || x > columns.length * colWidth) return;
  const top = ry + rh / 2;

  const el = document.createElement('div');
  el.className = 'gantt-item gantt-milestone';
  if (isSelected(ri, ii)) el.classList.add('selected');
  el.style.top = (top - 12) + 'px';
  el.title = `${item.label || ''}\n${item.date}`;

  const pos = item.labelPosition || 'after';
  let lblEl;
  if (pos === 'before') {
    lblEl = document.createElement('span');
    lblEl.className = 'milestone-label';
    lblEl.textContent = item.label || '';
    el.appendChild(lblEl);
  }
  const mark = document.createElement('span');
  mark.className = 'milestone-mark';
  mark.textContent = 'â–½';
  el.appendChild(mark);
  if (pos === 'after') {
    lblEl = document.createElement('span');
    lblEl.className = 'milestone-label';
    lblEl.textContent = item.label || '';
    el.appendChild(lblEl);
  }

  // Position: center the mark on x
  el.style.left = (x - 8) + 'px';

  if (appMode === 'edit') {
    el.addEventListener('mousedown', e => {
      if (el.querySelector('.inline-edit')) return;
      onItemMouseDown(e, ri, ii);
    });
    el.addEventListener('dblclick', e => {
      e.stopPropagation();
      if (lblEl) {
        startInlineEdit(el, lblEl, text => {
          state.rows[ri].items[ii].label = text;
          render();
        });
      }
    });
    el.addEventListener('contextmenu', e => {
      e.preventDefault(); e.stopPropagation();
      showContextMenu(e.clientX, e.clientY, [
        { label: t('editMilestoneItem'), action: () => editItemDialog(ri, ii) },
        { label: t('deleteItem'), action: () => { state.rows[ri].items.splice(ii, 1); selectedItems = []; render(); } }
      ]);
    });
  }
  layer.appendChild(el);
}

function getThunderPointsForRender() {
  // Build a point for every visible row: use explicit point if exists, otherwise default date
  const defDate = state.thunderLine.defaultDate || fmtDate(new Date());
  const explicitMap = {};
  state.thunderLine.points.forEach((p, i) => {
    explicitMap[p.rowIndex] = { date: p.date, explicitIndex: i };
  });
  const allPoints = [];
  visibleRows.forEach((entry, vi) => {
    const ri = entry.originalIndex;
    if (explicitMap[ri] !== undefined) {
      allPoints.push({ rowIndex: ri, displayIndex: vi, date: explicitMap[ri].date, explicit: true, explicitIndex: explicitMap[ri].explicitIndex });
    } else {
      allPoints.push({ rowIndex: ri, displayIndex: vi, date: defDate, explicit: false, explicitIndex: -1 });
    }
  });
  return allPoints;
}

function renderThunderLine() {
  const svg = document.getElementById('thunder-svg');
  const totalW = columns.length * colWidth;
  svg.setAttribute('width', totalW);
  svg.setAttribute('height', totalBodyHeight);
  svg.innerHTML = '';

  if (!state.thunderLine.visible || visibleRows.length === 0) return;

  const pts = getThunderPointsForRender();
  const coords = pts.map(p => {
    const vi = p.displayIndex;
    return {
      x: getXForDateCenter(p.date, columns, colWidth),
      y: rowYOffsets[vi] + rowHeights[vi] / 2,
      explicit: p.explicit,
      explicitIndex: p.explicitIndex,
      rowIndex: p.rowIndex,
      displayIndex: vi
    };
  });

  if (coords.length > 0) {
    const defX = getXForDateCenter(state.thunderLine.defaultDate || fmtDate(new Date()), columns, colWidth);
    const pathParts = [];
    pathParts.push(`${defX},${0}`);
    for (let i = 0; i < coords.length; i++) {
      pathParts.push(`${coords[i].x},${coords[i].y}`);
      const boundaryY = rowYOffsets[coords[i].displayIndex] + rowHeights[coords[i].displayIndex];
      pathParts.push(`${defX},${boundaryY}`);
    }

    const polyline = document.createElementNS('http://www.w3.org/2000/svg', 'polyline');
    polyline.setAttribute('points', pathParts.join(' '));
    polyline.setAttribute('stroke', '#d32f2f');
    polyline.setAttribute('stroke-width', '2');
    polyline.setAttribute('fill', 'none');
    svg.appendChild(polyline);
  }

  // Dots
  coords.forEach((c, i) => {
    const circle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
    circle.setAttribute('cx', c.x);
    circle.setAttribute('cy', c.y);
    circle.setAttribute('r', c.explicit ? 5 : 3);
    circle.setAttribute('fill', '#d32f2f');
    if (!c.explicit) circle.setAttribute('opacity', '0.5');
    circle.classList.add('thunder-dot');
    if (appMode === 'edit') {
      circle.addEventListener('mousedown', e => {
        if (e.button !== 0) return;
        e.preventDefault(); e.stopPropagation();
        startThunderDotDrag(e, c.rowIndex, c.explicit, c.explicitIndex);
      });
      circle.addEventListener('contextmenu', e => {
        e.preventDefault(); e.stopPropagation();
        if (c.explicit) {
          showContextMenu(e.clientX, e.clientY, [
            { label: t('deleteProgress'), action: () => { state.thunderLine.points.splice(c.explicitIndex, 1); render(); } }
          ]);
        }
      });
    }
    svg.appendChild(circle);
  });
}

// ===== Thunder Dot Drag =====
function startThunderDotDrag(e, rowIndex, isExplicit, explicitIndex) {
  const bodyScroll = document.getElementById('gantt-body-scroll');
  const scrollRect = bodyScroll.getBoundingClientRect();
  let pointIndex = explicitIndex;
  let moved = false;

  // If dragging a default (non-explicit) dot, create an explicit point on first move
  function ensureExplicit() {
    if (!isExplicit && pointIndex === -1) {
      const defDate = state.thunderLine.defaultDate || fmtDate(new Date());
      state.thunderLine.points.push({ rowIndex: rowIndex, date: defDate });
      pointIndex = state.thunderLine.points.length - 1;
      isExplicit = true;
    }
  }

  function onMove(ev) {
    moved = true;
    ensureExplicit();
    const mx = ev.clientX - scrollRect.left + bodyScroll.scrollLeft;
    const curDate = getDateForX(mx, columns, colWidth);
    state.thunderLine.points[pointIndex].date = fmtDate(curDate);
    showDragTooltip(ev, formatDateLabel(curDate));
    renderThunderLine();
  }

  function onUp() {
    document.removeEventListener('mousemove', onMove);
    document.removeEventListener('mouseup', onUp);
    hideDragTooltip();
    if (moved) render();
  }

  document.addEventListener('mousemove', onMove);
  document.addEventListener('mouseup', onUp);
}

// ===== Inline Edit =====
function startInlineEdit(parentEl, labelEl, onCommit) {
  if (parentEl.querySelector('.inline-edit')) return;

  const currentText = labelEl.textContent;
  labelEl.style.display = 'none';

  const input = document.createElement('input');
  input.type = 'text';
  input.className = 'inline-edit';
  input.value = currentText;

  // Insert input next to the hidden label
  labelEl.parentNode.insertBefore(input, labelEl.nextSibling);
  input.focus();
  input.select();

  let committed = false;
  function commit() {
    if (committed) return;
    committed = true;
    const newText = input.value;
    input.remove();
    labelEl.style.display = '';
    onCommit(newText);
  }
  function cancel() {
    if (committed) return;
    committed = true;
    input.remove();
    labelEl.style.display = '';
    labelEl.textContent = currentText;
  }

  input.addEventListener('keydown', e => {
    e.stopPropagation();
    if (e.key === 'Enter') { e.preventDefault(); commit(); }
    if (e.key === 'Escape') { e.preventDefault(); cancel(); }
  });
  input.addEventListener('blur', () => commit());
  input.addEventListener('mousedown', e => e.stopPropagation());
}

// ===== Selection =====
function isSelected(ri, ii) {
  return selectedItems.some(s => s.rowIndex === ri && s.itemIndex === ii);
}

function clearSelection() { selectedItems = []; }

function toggleSelect(ri, ii, multi) {
  const idx = selectedItems.findIndex(s => s.rowIndex === ri && s.itemIndex === ii);
  if (multi) {
    if (idx >= 0) selectedItems.splice(idx, 1);
    else selectedItems.push({ rowIndex: ri, itemIndex: ii });
  } else {
    if (idx >= 0 && selectedItems.length === 1) { /* already solo selected */ }
    else { selectedItems = [{ rowIndex: ri, itemIndex: ii }]; }
  }
}

// ===== Drag Tooltip =====
function showDragTooltip(ev, text) {
  const tip = document.getElementById('drag-tooltip');
  tip.textContent = text;
  tip.style.left = ev.clientX + 'px';
  tip.style.top = ev.clientY + 'px';
  tip.style.display = 'block';
}

function hideDragTooltip() {
  document.getElementById('drag-tooltip').style.display = 'none';
}

function formatDateLabel(d) {
  if (typeof d === 'string') d = parseDate(d);
  return `${d.getFullYear()}/${d.getMonth()+1}/${d.getDate()}`;
}

// ===== Drag & Resize =====
function onItemMouseDown(e, ri, ii) {
  if (e.button !== 0) return;
  e.stopPropagation();
  const wasSelected = isSelected(ri, ii);
  const multi = e.ctrlKey || e.metaKey;

  if (multi) {
    // Ctrl+click: toggle this item in/out of selection
    toggleSelect(ri, ii, true);
    if (!isSelected(ri, ii)) { render(); return; }
  } else if (!wasSelected) {
    // Click on unselected item without Ctrl: select only this one
    selectedItems = [{ rowIndex: ri, itemIndex: ii }];
  }
  // If already selected without Ctrl: keep current multi-selection for drag
  render();

  const bodyScroll = document.getElementById('gantt-body-scroll');
  const scrollRect = bodyScroll.getBoundingClientRect();
  const startBodyX = e.clientX - scrollRect.left + bodyScroll.scrollLeft;

  // Record original dates
  const originals = selectedItems.map(s => {
    const item = state.rows[s.rowIndex].items[s.itemIndex];
    if (item.type === 'task') return { startDate: item.startDate, endDate: item.endDate };
    return { date: item.date };
  });

  let moved = false;

  function onMove(ev) {
    const dx = ev.clientX - e.clientX;
    if (Math.abs(dx) < 3 && !moved) return;
    moved = true;
    const curBodyX = ev.clientX - scrollRect.left + bodyScroll.scrollLeft;
    const startDate = getDateForX(startBodyX, columns, colWidth);
    const curDate = getDateForX(curBodyX, columns, colWidth);
    const dayOffset = daysBetween(startDate, curDate);

    selectedItems.forEach((s, i) => {
      const item = state.rows[s.rowIndex].items[s.itemIndex];
      const orig = originals[i];
      if (item.type === 'task') {
        item.startDate = fmtDate(addDays(parseDate(orig.startDate), dayOffset));
        item.endDate = fmtDate(addDays(parseDate(orig.endDate), dayOffset));
      } else {
        item.date = fmtDate(addDays(parseDate(orig.date), dayOffset));
      }
    });

    // Show tooltip with current date(s)
    const first = state.rows[selectedItems[0].rowIndex].items[selectedItems[0].itemIndex];
    if (first.type === 'task') {
      showDragTooltip(ev, `${formatDateLabel(first.startDate)} ã€œ ${formatDateLabel(first.endDate)}`);
    } else {
      showDragTooltip(ev, formatDateLabel(first.date));
    }

    renderItems();
    renderThunderLine();
  }

  function onUp() {
    document.removeEventListener('mousemove', onMove);
    document.removeEventListener('mouseup', onUp);
    hideDragTooltip();
    if (moved) render();
  }

  document.addEventListener('mousemove', onMove);
  document.addEventListener('mouseup', onUp);
}

function startResize(e, ri, ii, side) {
  e.preventDefault(); e.stopPropagation();
  const item = state.rows[ri].items[ii];
  if (item.type !== 'task') return;

  const bodyScroll = document.getElementById('gantt-body-scroll');
  const scrollRect = bodyScroll.getBoundingClientRect();
  const origStart = item.startDate, origEnd = item.endDate;

  function onMove(ev) {
    const mx = ev.clientX - scrollRect.left + bodyScroll.scrollLeft;
    if (side === 'left') {
      const curDate = getDateForX(mx, columns, colWidth);
      const ed = parseDate(origEnd);
      if (curDate <= ed) item.startDate = fmtDate(curDate);
      showDragTooltip(ev, formatDateLabel(item.startDate));
    } else {
      // Right edge: subtract 1px so getDateForX returns the cell the edge belongs to
      const curDate = getDateForX(Math.max(0, mx - 1), columns, colWidth);
      const sd = parseDate(origStart);
      if (curDate >= sd) item.endDate = fmtDate(curDate);
      showDragTooltip(ev, formatDateLabel(item.endDate));
    }
    renderItems();
  }

  function onUp() {
    document.removeEventListener('mousemove', onMove);
    document.removeEventListener('mouseup', onUp);
    hideDragTooltip();
    render();
  }

  document.addEventListener('mousemove', onMove);
  document.addEventListener('mouseup', onUp);
}

// ===== Context Menu =====
function showContextMenu(x, y, items) {
  const menu = document.getElementById('context-menu');
  menu.innerHTML = '';
  items.forEach(it => {
    if (it.sep) {
      const s = document.createElement('div');
      s.className = 'menu-sep';
      menu.appendChild(s);
    } else {
      const d = document.createElement('div');
      d.className = 'menu-item';
      d.textContent = it.label;
      d.onclick = () => { hideContextMenu(); it.action(); };
      menu.appendChild(d);
    }
  });
  menu.style.left = x + 'px';
  menu.style.top = y + 'px';
  menu.style.display = 'block';
}

function hideContextMenu() {
  document.getElementById('context-menu').style.display = 'none';
}

document.addEventListener('click', e => {
  if (!e.target.closest('#context-menu')) hideContextMenu();
});

// Body context menu
document.addEventListener('DOMContentLoaded', () => {
  const bodyScroll = document.getElementById('gantt-body-scroll');

  bodyScroll.addEventListener('contextmenu', e => {
    if (appMode !== 'edit') return;
    e.preventDefault();
    const rect = document.getElementById('gantt-body').getBoundingClientRect();
    const x = e.clientX - rect.left;
    const y = e.clientY - rect.top;
    const vi = getVisibleRowIndexForY(y);
    if (vi < 0 || vi >= visibleRows.length) return;
    const ri = visibleRows[vi].originalIndex;
    const clickDate = getDateForX(x, columns, colWidth);
    const clickDateStr = fmtDate(clickDate);

    const menuItems = [
      { label: `${t('addTask')} (${clickDateStr})`, action: () => addTaskDialog(ri, clickDateStr) },
      { label: `${t('addMilestone')} (${clickDateStr})`, action: () => addMilestoneDialog(ri, clickDateStr) },
      { sep: true },
      { label: t('addProgress'), action: () => { addThunderPoint(ri, clickDateStr); } },
    ];

    if (selectedItems.length > 0) {
      menuItems.push({ sep: true });
      menuItems.push({ label: t('deleteSelected'), action: () => deleteSelected() });
    }

    showContextMenu(e.clientX, e.clientY, menuItems);
  });

  bodyScroll.addEventListener('mousedown', e => {
    if (e.button === 0 && !e.target.closest('.gantt-item') && !e.target.closest('.thunder-dot')) {
      clearSelection();
      render();
    }
  });

  // Sync scroll
  bodyScroll.addEventListener('scroll', () => {
    document.getElementById('gantt-header-scroll').scrollLeft = bodyScroll.scrollLeft;
    document.getElementById('gantt-sidebar-scroll').scrollTop = bodyScroll.scrollTop;
  });
});

// ===== Thunder Line =====
function addThunderPoint(ri, dateStr) {
  const existing = state.thunderLine.points.findIndex(p => p.rowIndex === ri);
  if (existing >= 0) {
    state.thunderLine.points[existing].date = dateStr;
  } else {
    state.thunderLine.points.push({ rowIndex: ri, date: dateStr });
  }
  render();
}

function toggleThunder(visible) {
  state.thunderLine.visible = visible;
  render();
}

function changeThunderDefault(dateStr) {
  state.thunderLine.defaultDate = dateStr;
  render();
}

// ===== Dialogs =====
function showModal(title, fields, onOk) {
  const overlay = document.createElement('div');
  overlay.className = 'modal-overlay';
  const modal = document.createElement('div');
  modal.className = 'modal';
  const h3 = document.createElement('h3');
  h3.textContent = title;
  modal.appendChild(h3);

  const inputs = {};
  fields.forEach(f => {
    const div = document.createElement('div');
    div.className = 'field';
    const label = document.createElement('label');
    label.textContent = f.label;
    div.appendChild(label);

    if (f.type === 'color') {
      const container = document.createElement('div');
      container.className = 'color-options';
      let selected = f.value || COLORS[0];
      COLORS.forEach(c => {
        const opt = document.createElement('div');
        opt.className = 'color-opt' + (c === selected ? ' selected' : '');
        opt.style.background = c;
        opt.onclick = () => {
          container.querySelectorAll('.color-opt').forEach(o => o.classList.remove('selected'));
          opt.classList.add('selected');
          selected = c;
          inputs[f.key] = { value: c };
        };
        container.appendChild(opt);
      });
      inputs[f.key] = { value: selected };
      div.appendChild(container);
    } else if (f.type === 'select') {
      const sel = document.createElement('select');
      f.options.forEach(o => {
        const opt = document.createElement('option');
        opt.value = o.value; opt.textContent = o.label;
        if (o.value === f.value) opt.selected = true;
        sel.appendChild(opt);
      });
      inputs[f.key] = sel;
      div.appendChild(sel);
    } else {
      const inp = document.createElement('input');
      inp.type = f.type || 'text';
      inp.value = f.value || '';
      inputs[f.key] = inp;
      div.appendChild(inp);
    }
    modal.appendChild(div);
  });

  const btns = document.createElement('div');
  btns.className = 'modal-btns';
  const btnCancel = document.createElement('button');
  btnCancel.textContent = t('cancel');
  btnCancel.onclick = () => overlay.remove();
  const btnOk = document.createElement('button');
  btnOk.className = 'btn-primary';
  btnOk.textContent = 'OK';
  btnOk.onclick = () => {
    const vals = {};
    for (const k in inputs) vals[k] = inputs[k].value;
    onOk(vals);
    overlay.remove();
  };
  btns.appendChild(btnCancel);
  btns.appendChild(btnOk);
  modal.appendChild(btns);

  overlay.appendChild(modal);
  overlay.addEventListener('mousedown', e => { if(e.target === overlay) overlay.remove(); });
  document.body.appendChild(overlay);

  // Focus first input
  const firstInput = modal.querySelector('input[type="text"], input[type="date"]');
  if (firstInput) setTimeout(() => firstInput.focus(), 50);
}

function getTaskLabelPosOptions() {
  return [
    { value: 'inside', label: t('posInside') },
    { value: 'above', label: t('posAbove') },
    { value: 'below', label: t('posBelow') },
    { value: 'left', label: t('posLeft') },
    { value: 'right', label: t('posRight') }
  ];
}

function addTaskDialog(ri, dateStr) {
  const endDate = fmtDate(addDays(parseDate(dateStr), 30));
  showModal(t('addTask'), [
    { key: 'label', label: t('label'), type: 'text', value: '' },
    { key: 'startDate', label: t('startDate'), type: 'date', value: dateStr },
    { key: 'endDate', label: t('endDate'), type: 'date', value: endDate },
    { key: 'color', label: t('color'), type: 'color', value: COLORS[0] },
    { key: 'taskLabelPosition', label: t('labelPos'), type: 'select', value: 'inside', options: getTaskLabelPosOptions() }
  ], vals => {
    if (!vals.startDate || !vals.endDate) return;
    state.rows[ri].items.push({
      type: 'task', startDate: vals.startDate, endDate: vals.endDate,
      label: vals.label, color: vals.color, taskLabelPosition: vals.taskLabelPosition
    });
    render();
  });
}

function addMilestoneDialog(ri, dateStr) {
  showModal(t('addMilestone'), [
    { key: 'label', label: t('label'), type: 'text', value: '' },
    { key: 'date', label: t('date'), type: 'date', value: dateStr },
    { key: 'labelPosition', label: t('labelPos'), type: 'select', value: 'after',
      options: [{ value: 'before', label: t('posBefore') }, { value: 'after', label: t('posAfter') }] }
  ], vals => {
    if (!vals.date) return;
    state.rows[ri].items.push({
      type: 'milestone', date: vals.date,
      label: vals.label, labelPosition: vals.labelPosition
    });
    render();
  });
}

function editItemDialog(ri, ii) {
  const item = state.rows[ri].items[ii];
  if (item.type === 'task') {
    showModal(t('editTask'), [
      { key: 'label', label: t('label'), type: 'text', value: item.label },
      { key: 'startDate', label: t('startDate'), type: 'date', value: item.startDate },
      { key: 'endDate', label: t('endDate'), type: 'date', value: item.endDate },
      { key: 'color', label: t('color'), type: 'color', value: item.color || COLORS[0] },
      { key: 'taskLabelPosition', label: t('labelPos'), type: 'select', value: item.taskLabelPosition || 'inside', options: getTaskLabelPosOptions() }
    ], vals => {
      if (!vals.startDate || !vals.endDate) return;
      item.label = vals.label;
      item.startDate = vals.startDate;
      item.endDate = vals.endDate;
      item.color = vals.color;
      item.taskLabelPosition = vals.taskLabelPosition;
      render();
    });
  } else {
    showModal(t('editMilestone'), [
      { key: 'label', label: t('label'), type: 'text', value: item.label },
      { key: 'date', label: t('date'), type: 'date', value: item.date },
      { key: 'labelPosition', label: t('labelPos'), type: 'select', value: item.labelPosition || 'after',
        options: [{ value: 'before', label: t('posBefore') }, { value: 'after', label: t('posAfter') }] }
    ], vals => {
      if (!vals.date) return;
      item.label = vals.label;
      item.date = vals.date;
      item.labelPosition = vals.labelPosition;
      render();
    });
  }
}

function deleteSelected() {
  // Delete in reverse order to maintain indices
  const sorted = [...selectedItems].sort((a, b) => b.rowIndex - a.rowIndex || b.itemIndex - a.itemIndex);
  sorted.forEach(s => {
    state.rows[s.rowIndex].items.splice(s.itemIndex, 1);
  });
  selectedItems = [];
  render();
}

// ===== Mode =====
function setMode(mode) {
  appMode = mode;
  document.getElementById('btn-edit-mode').classList.toggle('active', mode === 'edit');
  document.getElementById('btn-view-mode').classList.toggle('active', mode === 'view');
  document.getElementById('edit-controls').style.display = mode === 'edit' ? '' : 'none';
  document.getElementById('view-controls').style.display = mode === 'view' ? '' : 'none';
  document.body.classList.toggle('edit-mode', mode === 'edit');
  document.body.classList.toggle('view-mode', mode === 'view');

  customColWidth = null;
  if (mode === 'view') {
    clearSelection();
    if (!viewRange) {
      document.getElementById('view-start').value = state.startDate;
      document.getElementById('view-end').value = state.endDate;
    }
  } else {
    viewRange = null;
  }
  render();
}

// ===== Time Unit =====
function changeUnit(unit) {
  state.timeUnit = unit;
  customColWidth = null;
  render();
}

// ===== Font Size =====
function changeFontSize(delta) {
  state.fontSize = Math.max(8, Math.min(24, state.fontSize + delta));
  document.documentElement.style.setProperty('--font-size', state.fontSize + 'px');
  render();
}

// ===== Column Add/Remove =====
function addColumnStart() {
  const sd = parseDate(state.startDate);
  if (state.timeUnit === 'month') {
    state.startDate = fmtDate(new Date(sd.getFullYear(), sd.getMonth() - 1, 1));
  } else if (state.timeUnit === 'week') {
    state.startDate = fmtDate(addDays(sd, -7));
  } else {
    state.startDate = fmtDate(addDays(sd, -1));
  }
  render();
}

function addColumnEnd() {
  const ed = parseDate(state.endDate);
  if (state.timeUnit === 'month') {
    const next = new Date(ed.getFullYear(), ed.getMonth() + 1, 1);
    state.endDate = fmtDate(monthEnd(next));
  } else if (state.timeUnit === 'week') {
    state.endDate = fmtDate(addDays(ed, 7));
  } else {
    state.endDate = fmtDate(addDays(ed, 1));
  }
  render();
}

function removeColumnStart() {
  const sd = parseDate(state.startDate);
  let newStart;
  if (state.timeUnit === 'month') {
    newStart = new Date(sd.getFullYear(), sd.getMonth() + 1, 1);
  } else if (state.timeUnit === 'week') {
    newStart = addDays(sd, 7);
  } else {
    newStart = addDays(sd, 1);
  }
  if (newStart < parseDate(state.endDate)) {
    state.startDate = fmtDate(newStart);
    render();
  }
}

function removeColumnEnd() {
  const ed = parseDate(state.endDate);
  let newEnd;
  if (state.timeUnit === 'month') {
    newEnd = new Date(ed.getFullYear(), ed.getMonth(), 0);
  } else if (state.timeUnit === 'week') {
    newEnd = addDays(ed, -7);
  } else {
    newEnd = addDays(ed, -1);
  }
  if (newEnd > parseDate(state.startDate)) {
    state.endDate = fmtDate(newEnd);
    render();
  }
}

// ===== Row =====
function addRow() {
  state.rows.push({ name: t('newTask'), items: [] });
  render();
}

// ===== View Range =====
function applyViewRange() {
  const vs = document.getElementById('view-start').value;
  const ve = document.getElementById('view-end').value;
  if (vs && ve && vs <= ve) {
    viewRange = { start: vs, end: ve };
    render();
  }
}

function clearViewRange() {
  viewRange = null;
  document.getElementById('view-start').value = state.startDate;
  document.getElementById('view-end').value = state.endDate;
  render();
}

// ===== Export / Import =====
function exportJSON() {
  const json = JSON.stringify(state, null, 2);
  const blob = new Blob([json], { type: 'application/json' });
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url;
  a.download = 'gantt_chart.json';
  a.click();
  URL.revokeObjectURL(url);
  showToast(t('exported'));
}

function importJSON() {
  document.getElementById('file-input').click();
}

function loadJSONFile(file) {
  const reader = new FileReader();
  reader.onload = e => {
    try {
      const data = JSON.parse(e.target.result);
      if (data.rows && data.startDate && data.endDate) {
        state = data;
        if (!state.thunderLine) state.thunderLine = { visible: true, points: [], defaultDate: fmtDate(new Date()) };
        if (!state.thunderLine.defaultDate) state.thunderLine.defaultDate = fmtDate(new Date());
        if (!state.fontSize) state.fontSize = 14;
        if (state.cornerLabel === undefined) state.cornerLabel = '';
        if (state.lang) { currentLang = state.lang; } else { state.lang = currentLang; }
        document.getElementById('sel-lang').value = currentLang;
        updateUIText();
        document.getElementById('sel-unit').value = state.timeUnit || 'month';
        document.getElementById('chk-thunder').checked = state.thunderLine.visible;
        document.getElementById('thunder-default-date').value = state.thunderLine.defaultDate;
        selectedItems = [];
        customColWidth = null;
        viewRange = null;
        render();
        showToast(t('imported'));
      } else {
        alert(t('invalidFile'));
      }
    } catch (err) {
      alert(t('jsonError') + err.message);
    }
  };
  reader.readAsText(file);
}

function handleFileImport(event) {
  const file = event.target.files[0];
  if (!file) return;
  loadJSONFile(file);
  event.target.value = '';
}

// ===== Image Copy =====
async function copyAsImage() {
  const canvas = renderToCanvas();
  try {
    const blob = await new Promise(resolve => canvas.toBlob(resolve, 'image/png'));
    await navigator.clipboard.write([new ClipboardItem({ 'image/png': blob })]);
    showToast(t('imageCopied'));
  } catch (err) {
    // Fallback: download
    canvas.toBlob(blob => {
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url; a.download = 'gantt_chart.png'; a.click();
      URL.revokeObjectURL(url);
      showToast(t('imageDownloaded'));
    });
  }
}

function renderToCanvas() {
  const bh = parseInt(getComputedStyle(document.documentElement).getPropertyValue('--bar-height'));
  const sw = parseInt(getComputedStyle(document.documentElement).getPropertyValue('--sidebar-width'));
  const hh = parseInt(getComputedStyle(document.documentElement).getPropertyValue('--header-height'));
  const fs = state.fontSize;

  computeRowLayout();

  const totalW = columns.length * colWidth + sw;
  const totalH = totalBodyHeight + hh;

  const dpr = window.devicePixelRatio || 1;
  const canvas = document.createElement('canvas');
  canvas.width = totalW * dpr;
  canvas.height = totalH * dpr;
  const ctx = canvas.getContext('2d');
  ctx.scale(dpr, dpr);

  // ===== Pass 1: Backgrounds =====
  ctx.fillStyle = '#fff';
  ctx.fillRect(0, 0, totalW, totalH);

  // Header background
  ctx.fillStyle = '#f0f4f8';
  ctx.fillRect(0, 0, totalW, hh);

  // Weekend column backgrounds
  columns.forEach((col, i) => {
    if (col.weekend) {
      const x = sw + i * colWidth;
      ctx.fillStyle = '#fff3e0';
      ctx.fillRect(x, 0, colWidth, totalH);
    }
  });

  // Row backgrounds
  visibleRows.forEach((entry, vi) => {
    const rh = rowHeights[vi];
    const y = hh + rowYOffsets[vi];
    ctx.fillStyle = vi % 2 === 0 ? '#fafbfc' : '#fff';
    ctx.fillRect(0, y, sw, rh);
  });

  // ===== Pass 2: Grid lines =====
  // Column vertical lines (body)
  ctx.strokeStyle = '#e8e8e8';
  ctx.lineWidth = 1;
  columns.forEach((col, i) => {
    const x = sw + i * colWidth;
    ctx.beginPath(); ctx.moveTo(x + colWidth, hh); ctx.lineTo(x + colWidth, totalH); ctx.stroke();
  });

  // Column vertical lines (header)
  ctx.strokeStyle = '#d0d0d0';
  ctx.lineWidth = 1;
  columns.forEach((col, i) => {
    const x = sw + i * colWidth;
    ctx.beginPath(); ctx.moveTo(x + colWidth, 0); ctx.lineTo(x + colWidth, hh); ctx.stroke();
  });

  // Year-start vertical lines (thicker)
  let prevYear = null;
  columns.forEach((col, i) => {
    const x = sw + i * colWidth;
    if (col.year !== prevYear && i > 0) {
      ctx.strokeStyle = '#bbb';
      ctx.lineWidth = 2;
      ctx.beginPath(); ctx.moveTo(x, 0); ctx.lineTo(x, totalH); ctx.stroke();
    }
    prevYear = col.year;
  });

  // Row horizontal lines
  ctx.strokeStyle = '#d0d0d0';
  ctx.lineWidth = 1;
  visibleRows.forEach((entry, vi) => {
    const rh = rowHeights[vi];
    const y = hh + rowYOffsets[vi];
    ctx.beginPath(); ctx.moveTo(0, y + rh); ctx.lineTo(totalW, y + rh); ctx.stroke();
  });

  // Header bottom line & Sidebar border
  ctx.strokeStyle = '#bbb';
  ctx.lineWidth = 2;
  ctx.beginPath(); ctx.moveTo(0, hh); ctx.lineTo(totalW, hh); ctx.stroke();
  ctx.beginPath(); ctx.moveTo(sw, 0); ctx.lineTo(sw, totalH); ctx.stroke();

  // ===== Pass 3: Text & Items =====
  // Corner label
  ctx.fillStyle = '#666';
  ctx.font = `bold ${fs * 0.85}px sans-serif`;
  ctx.textBaseline = 'middle';
  ctx.fillText(state.cornerLabel || t('taskName'), 8, hh / 2);

  // Header labels
  ctx.font = `600 ${fs * 0.85}px sans-serif`;
  prevYear = null;
  columns.forEach((col, i) => {
    const x = sw + i * colWidth;
    let lbl = col.label;
    if (col.year !== prevYear) {
      if (state.timeUnit === 'month') lbl = col.year + '/' + lbl;
      prevYear = col.year;
    }
    ctx.fillStyle = '#555';
    ctx.fillText(lbl, x + 4, hh / 2 + 4);
  });

  // Rows: names & items
  visibleRows.forEach((entry, vi) => {
    const row = entry.row;
    const rh = rowHeights[vi];
    const y = hh + rowYOffsets[vi];

    // Row name (with wrapping and explicit line breaks)
    ctx.fillStyle = '#333';
    ctx.font = `${fs}px sans-serif`;
    ctx.textBaseline = 'top';
    const maxTextW = sw - 16;
    const lineH = fs * 1.3;
    let lines = [];
    const paragraphs = row.name.split('\n');
    paragraphs.forEach(para => {
      let curLine = '';
      for (const ch of para) {
        const testLine = curLine + ch;
        if (ctx.measureText(testLine).width > maxTextW && curLine) {
          lines.push(curLine);
          curLine = ch;
        } else {
          curLine = testLine;
        }
      }
      lines.push(curLine);
    });
    const totalTextH = lines.length * lineH;
    const textStartY = y + (rh - totalTextH) / 2;
    lines.forEach((line, li) => {
      ctx.fillText(line, 8, textStartY + li * lineH);
    });

    // Items
    row.items.forEach(item => {
      if (item.type === 'task') {
        const x1 = sw + getXForDate(item.startDate, columns, colWidth);
        const x2 = sw + getXForDateEnd(item.endDate, columns, colWidth);
        const w = Math.max(x2 - x1, 4);
        const barY = y + (rh - bh) / 2;

        ctx.fillStyle = item.color || COLORS[0];
        roundRect(ctx, x1, barY, w, bh, 4);
        ctx.fill();

        // Shadow
        ctx.shadowColor = 'rgba(0,0,0,.15)';
        ctx.shadowBlur = 3;
        ctx.shadowOffsetY = 1;
        roundRect(ctx, x1, barY, w, bh, 4);
        ctx.fill();
        ctx.shadowColor = 'transparent';
        ctx.shadowBlur = 0;
        ctx.shadowOffsetY = 0;

        if (item.label) {
          const tlp = item.taskLabelPosition || 'inside';
          ctx.font = `${fs * 0.8}px sans-serif`;
          ctx.textBaseline = 'middle';
          const tw = ctx.measureText(item.label).width;
          if (tlp === 'inside') {
            ctx.fillStyle = '#fff';
            if (tw < w - 8) {
              ctx.fillText(item.label, x1 + (w - tw) / 2, barY + bh / 2);
            }
          } else {
            ctx.fillStyle = '#333';
            if (tlp === 'above') {
              ctx.textBaseline = 'alphabetic';
              ctx.fillText(item.label, x1, barY - 4);
              ctx.textBaseline = 'middle';
            } else if (tlp === 'below') {
              ctx.textBaseline = 'top';
              ctx.fillText(item.label, x1, barY + bh + 4);
              ctx.textBaseline = 'middle';
            } else if (tlp === 'left') {
              ctx.fillText(item.label, x1 - tw - 4, barY + bh / 2);
            } else if (tlp === 'right') {
              ctx.fillText(item.label, x1 + w + 4, barY + bh / 2);
            }
          }
        }
      } else if (item.type === 'milestone') {
        const x = sw + getXForDateCenter(item.date, columns, colWidth);
        const my = y + rh / 2;
        ctx.fillStyle = '#d32f2f';
        ctx.font = `${fs * 1.3}px sans-serif`;
        ctx.textBaseline = 'middle';
        const markW = ctx.measureText('â–½').width;
        ctx.fillText('â–½', x - markW / 2, my);

        if (item.label) {
          ctx.fillStyle = '#333';
          ctx.font = `${fs * 0.8}px sans-serif`;
          if (item.labelPosition === 'before') {
            const lw = ctx.measureText(item.label).width;
            ctx.fillText(item.label, x - markW / 2 - lw - 4, my);
          } else {
            ctx.fillText(item.label, x + markW / 2 + 4, my);
          }
        }
      }
    });
  });

  // Thunder line
  if (state.thunderLine.visible && visibleRows.length > 0) {
    const pts = getThunderPointsForRender();
    const coords = pts.map(p => ({
      x: sw + getXForDateCenter(p.date, columns, colWidth),
      y: hh + rowYOffsets[p.displayIndex] + rowHeights[p.displayIndex] / 2,
      explicit: p.explicit,
      displayIndex: p.displayIndex
    }));

    if (coords.length > 0) {
      const defX = sw + getXForDateCenter(state.thunderLine.defaultDate || fmtDate(new Date()), columns, colWidth);
      ctx.strokeStyle = '#d32f2f';
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.moveTo(defX, hh);
      for (let i = 0; i < coords.length; i++) {
        ctx.lineTo(coords[i].x, coords[i].y);
        const boundaryY = hh + rowYOffsets[coords[i].displayIndex] + rowHeights[coords[i].displayIndex];
        ctx.lineTo(defX, boundaryY);
      }
      ctx.stroke();
    }

    coords.forEach(c => {
      ctx.beginPath();
      ctx.arc(c.x, c.y, c.explicit ? 5 : 3, 0, Math.PI * 2);
      ctx.fillStyle = '#d32f2f';
      ctx.globalAlpha = c.explicit ? 1 : 0.5;
      ctx.fill();
      ctx.globalAlpha = 1;
    });
  }

  return canvas;
}

function roundRect(ctx, x, y, w, h, r) {
  ctx.beginPath();
  ctx.moveTo(x + r, y);
  ctx.lineTo(x + w - r, y);
  ctx.quadraticCurveTo(x + w, y, x + w, y + r);
  ctx.lineTo(x + w, y + h - r);
  ctx.quadraticCurveTo(x + w, y + h, x + w - r, y + h);
  ctx.lineTo(x + r, y + h);
  ctx.quadraticCurveTo(x, y + h, x, y + h - r);
  ctx.lineTo(x, y + r);
  ctx.quadraticCurveTo(x, y, x + r, y);
  ctx.closePath();
}

// ===== Toast =====
function showToast(msg) {
  const toast = document.getElementById('toast');
  toast.textContent = msg;
  toast.style.display = 'block';
  setTimeout(() => { toast.style.display = 'none'; }, 2000);
}

// ===== Resize Handle (drag right edge of last column to change column width) =====
function initResizeHandle() {
  const handle = document.getElementById('gantt-resize-handle');

  handle.addEventListener('mousedown', e => {
    if (e.button !== 0) return;
    e.preventDefault();
    e.stopPropagation();
    const startX = e.clientX;
    const startTotalW = columns.length * colWidth;
    const numCols = columns.length;
    handle.classList.add('active');

    function onMove(ev) {
      const dx = ev.clientX - startX;
      const newTotalW = Math.max(numCols * 20, startTotalW + dx);
      const newCW = Math.max(20, Math.round(newTotalW / numCols));
      if (newCW !== colWidth) {
        customColWidth = newCW;
        colWidth = newCW;
        document.documentElement.style.setProperty('--col-width', colWidth + 'px');
        render();
      }
    }

    function onUp() {
      document.removeEventListener('mousemove', onMove);
      document.removeEventListener('mouseup', onUp);
      handle.classList.remove('active');
    }

    document.addEventListener('mousemove', onMove);
    document.addEventListener('mouseup', onUp);
  });
}

// ===== Sidebar Resize Handle =====
function initSidebarResizeHandle() {
  const handle = document.getElementById('sidebar-resize-handle');

  handle.addEventListener('mousedown', e => {
    if (e.button !== 0) return;
    e.preventDefault();
    e.stopPropagation();
    const startX = e.clientX;
    const startWidth = parseInt(getComputedStyle(document.documentElement).getPropertyValue('--sidebar-width'));
    handle.classList.add('active');

    function onMove(ev) {
      const dx = ev.clientX - startX;
      const newWidth = Math.max(80, Math.min(600, startWidth + dx));
      document.documentElement.style.setProperty('--sidebar-width', newWidth + 'px');
      render();
    }

    function onUp() {
      document.removeEventListener('mousemove', onMove);
      document.removeEventListener('mouseup', onUp);
      handle.classList.remove('active');
    }

    document.addEventListener('mousemove', onMove);
    document.addEventListener('mouseup', onUp);
  });
}

// ===== Init =====
document.addEventListener('DOMContentLoaded', () => {
  document.body.classList.add('edit-mode');
  document.getElementById('thunder-default-date').value = state.thunderLine.defaultDate;
  updateUIText();
  initResizeHandle();
  initSidebarResizeHandle();

  // Corner label editing
  const corner = document.getElementById('gantt-corner');
  corner.addEventListener('blur', () => {
    const text = corner.textContent.trim();
    state.cornerLabel = text === t('taskName') ? '' : text;
  });
  corner.addEventListener('keydown', e => {
    if (e.key === 'Enter') { e.preventDefault(); corner.blur(); }
  });

  render();

  // File drag & drop import
  document.addEventListener('dragover', e => { e.preventDefault(); });
  document.addEventListener('drop', e => {
    e.preventDefault();
    const file = e.dataTransfer.files[0];
    if (file && file.name.endsWith('.json')) {
      loadJSONFile(file);
    }
  });
});

// Keyboard
document.addEventListener('keydown', e => {
  if (e.key === 'Delete' || e.key === 'Backspace') {
    if (appMode === 'edit' && selectedItems.length > 0 && !document.querySelector('.modal-overlay') && document.activeElement.tagName !== 'INPUT' && !document.activeElement.isContentEditable) {
      e.preventDefault();
      deleteSelected();
    }
  }
  if (e.key === 'Escape') {
    hideContextMenu();
    const overlay = document.querySelector('.modal-overlay');
    if (overlay) overlay.remove();
    if (selectedItems.length > 0) { clearSelection(); render(); }
  }
});
</script>
</body>
</html>
