<!--
  Copyright 2026 Shogo Matsumoto

  Licensed under the Apache License, Version 2.0 (the "License");
  you may not use this file except in compliance with the License.
  You may obtain a copy of the License at

      http://www.apache.org/licenses/LICENSE-2.0

  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an "AS IS" BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License.
-->
<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Gantt Chart</title>
<style>
:root {
  --font-size: 14px;
  --row-height: 44px;
  --header-height: 36px;
  --sidebar-width: 180px;
  --col-width: 80px;
  --bar-height: 24px;
  --border-color: #d0d0d0;
  --header-bg: #f0f4f8;
  --row-even-bg: #fafbfc;
  --row-odd-bg: #ffffff;
  --accent: #2196F3;
}
* { margin: 0; padding: 0; box-sizing: border-box; }
body { font-family: 'Segoe UI', 'Hiragino Sans', 'Meiryo', sans-serif; font-size: var(--font-size); background: #eef1f5; color: #333; }

#toolbar {
  display: flex; flex-wrap: wrap; align-items: center; gap: 8px;
  padding: 8px 12px; background: #fff; border-bottom: 1px solid #ccc;
  box-shadow: 0 1px 3px rgba(0,0,0,.08); position: sticky; top: 0; z-index: 100;
}
#toolbar label { font-size: 0.85em; color: #555; }
#toolbar select, #toolbar input, #toolbar button {
  font-size: 0.85em; padding: 4px 8px; border: 1px solid #bbb; border-radius: 4px;
}
#toolbar button {
  background: #fff; cursor: pointer; transition: background .15s;
}
#toolbar button:hover { background: #e3f0fc; }
#toolbar button.active { background: var(--accent); color: #fff; border-color: var(--accent); }
.toolbar-sep { width: 1px; height: 24px; background: #ccc; margin: 0 4px; }
.toolbar-group { display: flex; align-items: center; gap: 4px; }

#gantt-wrapper {
  display: grid;
  grid-template-columns: var(--sidebar-width) 1fr;
  grid-template-rows: var(--header-height) 1fr;
  margin: 12px;
  background: #fff;
  border: 1px solid #bbb;
  border-radius: 6px;
  overflow: hidden;
  box-shadow: 0 2px 8px rgba(0,0,0,.07);
  position: relative;
}
#gantt-resize-handle {
  position: absolute; top: 0; width: 8px; height: 100%;
  cursor: col-resize; z-index: 20;
}
#gantt-resize-handle:hover, #gantt-resize-handle.active {
  background: var(--accent); opacity: 0.4; border-radius: 2px;
}
#sidebar-resize-handle {
  position: absolute; top: 0; width: 8px; height: 100%;
  cursor: col-resize; z-index: 20;
  left: calc(var(--sidebar-width) - 4px);
}
#sidebar-resize-handle:hover, #sidebar-resize-handle.active {
  background: var(--accent); opacity: 0.4; border-radius: 2px;
}
#body-height-resize-handle {
  position: absolute; bottom: 0; left: 0; width: 100%; height: 6px;
  cursor: ns-resize; z-index: 20;
}
#body-height-resize-handle:hover, #body-height-resize-handle.active {
  background: var(--accent); opacity: 0.4;
}
#gantt-corner {
  grid-row: 1; grid-column: 1;
  background: var(--header-bg);
  border-right: 2px solid var(--border-color);
  border-bottom: 2px solid var(--border-color);
  display: flex; align-items: center; justify-content: center;
  font-weight: bold; font-size: 0.85em; color: #666;
  outline: none; cursor: text; min-width: 0; overflow: hidden;
  white-space: nowrap; text-overflow: ellipsis; padding: 0 6px;
}
#gantt-corner:focus { background: #e8f0fe; }
#gantt-header-scroll {
  grid-row: 1; grid-column: 2;
  overflow-x: auto;
  overflow-y: hidden;
  border-bottom: 2px solid var(--border-color);
  background: var(--header-bg);
  scrollbar-width: none;
  -ms-overflow-style: none;
}
#gantt-header-scroll::-webkit-scrollbar { display: none; }
#gantt-header {
  display: flex; height: 100%;
}
.header-cell {
  flex: 0 0 var(--col-width);
  border-right: 1px solid var(--border-color);
  display: flex; align-items: flex-end;
  padding: 2px 4px; font-size: 0.85em; color: #555; font-weight: 600;
  white-space: nowrap; overflow: hidden;
}
.header-cell.year-start { border-left: 2px solid #999; }
.header-cell.weekend { background: #fff3e0; }
.body-cell.weekend { background: #fff3e0; }

#gantt-sidebar-scroll {
  grid-row: 2; grid-column: 1;
  overflow: hidden;
  border-right: 2px solid var(--border-color);
  position: relative;
}
#gantt-sidebar { }
.sidebar-row {
  border-bottom: 1px solid var(--border-color);
  display: flex; align-items: center;
  padding: 2px 6px; gap: 4px;
  min-height: var(--row-height);
}
.sidebar-row:nth-child(even) { background: var(--row-even-bg); }
.sidebar-name {
  flex: 1; min-width: 0; overflow-wrap: break-word; word-break: break-word;
  white-space: pre-wrap;
  outline: none; font-size: inherit; border: none; background: transparent;
  padding: 2px 4px; border-radius: 3px;
}
.sidebar-name:focus { background: #e8f0fe; }
.sidebar-name[contenteditable="false"] { cursor: default; }
.sidebar-btns { display: flex; gap: 2px; opacity: 0; transition: opacity .15s; }
.sidebar-row:hover .sidebar-btns { opacity: 1; }
.sidebar-btns button {
  width: 20px; height: 20px; border: none; background: transparent;
  cursor: pointer; font-size: 14px; color: #888; border-radius: 3px; line-height: 20px; padding: 0;
}
.sidebar-btns button:hover { background: #ddd; color: #333; }
.sidebar-drag-handle {
  cursor: grab; color: #bbb; font-size: 14px; padding: 0 2px;
  user-select: none; flex-shrink: 0;
}
.sidebar-drag-handle:hover { color: #666; }
.sidebar-row.drag-over-above { box-shadow: inset 0 3px 0 0 var(--accent); }
.sidebar-row.drag-over-below { box-shadow: inset 0 -3px 0 0 var(--accent); }
.sidebar-row.dragging { opacity: 0.4; }
.sidebar-collapse-btn {
  cursor: pointer; font-size: 10px; flex-shrink: 0; width: 16px; height: 16px;
  text-align: center; user-select: none; color: #888; line-height: 16px;
  border: 1px solid #ccc; border-radius: 2px; background: #f5f5f5;
}
.sidebar-collapse-btn:hover { color: #333; background: #ddd; }
.sidebar-row.row-collapsed { overflow: hidden; min-height: 0 !important; height: 20px !important; max-height: 20px !important; }
.sidebar-row.row-collapsed .sidebar-name { opacity: 0.5; font-size: 0.85em; }

#gantt-body-scroll {
  grid-row: 2; grid-column: 2;
  overflow-x: auto;
  overflow-y: hidden;
  position: relative;
}
#gantt-body {
  position: relative;
}
.body-row {
  display: flex;
  border-bottom: 1px solid var(--border-color);
}
.body-row:nth-child(even) { background: var(--row-even-bg); }
.body-cell {
  flex: 0 0 var(--col-width);
  border-right: 1px solid #e8e8e8;
  height: 100%;
}
.body-cell.year-start { border-left: 2px solid #bbb; }

#items-layer {
  position: absolute; top: 0; left: 0; pointer-events: none;
}
.gantt-item { position: absolute; pointer-events: auto; cursor: pointer; }
.gantt-task {
  height: var(--bar-height); border-radius: 4px;
  display: flex; align-items: center; justify-content: center;
  font-size: 0.8em; color: #fff; overflow: hidden;
  white-space: nowrap; text-overflow: ellipsis; padding: 0 6px;
  border: 2px solid transparent;
  transition: box-shadow .1s;
}
.gantt-task:hover { box-shadow: 0 2px 6px rgba(0,0,0,.25); }
.gantt-task.selected { border-color: var(--accent); box-shadow: 0 0 0 2px rgba(33,150,243,.3); }
.gantt-task .resize-handle {
  position: absolute; top: 0; width: 6px; height: 100%; cursor: ew-resize;
  opacity: 0;
}
.gantt-task .resize-handle.left { left: -2px; }
.gantt-task .resize-handle.right { right: -2px; }
.edit-mode .gantt-task:hover .resize-handle { opacity: 1; background: rgba(0,0,0,.15); }

.gantt-milestone {
  display: flex; align-items: center; gap: 2px;
  font-size: 0.8em; white-space: nowrap;
  border: 2px solid transparent; border-radius: 3px; padding: 1px 3px;
}
.gantt-milestone.selected { border-color: var(--accent); background: rgba(33,150,243,.08); }

.task-label { pointer-events: none; overflow: hidden; text-overflow: ellipsis; }
.task-label-outside {
  position: absolute; pointer-events: none; white-space: nowrap;
  font-size: inherit; color: #333;
}
.task-label-outside.pos-above { bottom: 100%; left: 0; margin-bottom: 1px; }
.task-label-outside.pos-below { top: 100%; left: 0; margin-top: 1px; }
.task-label-outside.pos-left { right: 100%; top: 50%; transform: translateY(-50%); margin-right: 4px; }
.task-label-outside.pos-right { left: 100%; top: 50%; transform: translateY(-50%); margin-left: 4px; }
.inline-edit {
  background: rgba(255,255,255,.95); color: #333; border: 1px solid var(--accent);
  border-radius: 3px; padding: 1px 4px; font-size: inherit;
  outline: none; min-width: 40px; max-width: 100%;
  pointer-events: auto; position: relative; z-index: 10;
}
.gantt-task .inline-edit { max-width: calc(100% - 12px); }
.gantt-milestone .inline-edit { min-width: 60px; }
.milestone-mark { font-size: 1.3em; color: #d32f2f; line-height: 1; }
.milestone-label { color: #333; }

.lane-separator {
  position: absolute; left: 0; height: 0;
  border-top: 1px dashed #ccc;
  pointer-events: none;
  z-index: 1;
}

#arrow-svg {
  position: absolute; top: 0; left: 0; pointer-events: none; z-index: 4;
}
#arrow-svg path { pointer-events: stroke; cursor: pointer; }
#arrow-svg path:hover { stroke: #d32f2f; stroke-width: 2.5; }

.arrow-anchor {
  position: absolute; width: 10px; height: 10px; border-radius: 50%;
  background: var(--accent); opacity: 0; cursor: crosshair;
  z-index: 6; pointer-events: auto; transform: translate(-50%, -50%);
  transition: opacity .15s;
}
.edit-mode .gantt-item:hover .arrow-anchor,
.arrow-anchor.active { opacity: 0.8; }

#thunder-svg {
  position: absolute; top: 0; left: 0; pointer-events: none; z-index: 5;
}
.thunder-dot {
  pointer-events: auto; cursor: grab;
}
.thunder-dot:active { cursor: grabbing; }

/* Context Menu */
#context-menu {
  position: fixed; background: #fff; border: 1px solid #ccc; border-radius: 6px;
  box-shadow: 0 4px 16px rgba(0,0,0,.15); z-index: 200; min-width: 160px;
  padding: 4px 0; display: none;
}
#context-menu .menu-item {
  padding: 6px 16px; cursor: pointer; font-size: 0.9em;
}
#context-menu .menu-item:hover { background: #e8f0fe; }
#context-menu .menu-sep { height: 1px; background: #e0e0e0; margin: 4px 0; }

/* Modal */
.modal-overlay {
  position: fixed; top: 0; left: 0; width: 100%; height: 100%;
  background: rgba(0,0,0,.35); z-index: 300;
  display: flex; align-items: center; justify-content: center;
}
.modal {
  background: #fff; border-radius: 8px; padding: 20px; min-width: 320px;
  box-shadow: 0 8px 32px rgba(0,0,0,.2);
}
.modal h3 { margin-bottom: 12px; font-size: 1.1em; }
.modal .field { margin-bottom: 10px; }
.modal .field label { display: block; font-size: 0.85em; color: #555; margin-bottom: 3px; }
.modal .field input, .modal .field select {
  width: 100%; padding: 6px 8px; border: 1px solid #bbb; border-radius: 4px; font-size: 0.95em;
}
.modal .field .color-options { display: flex; gap: 6px; flex-wrap: wrap; }
.modal .field .color-opt {
  width: 28px; height: 28px; border-radius: 50%; cursor: pointer;
  border: 3px solid transparent; transition: border-color .1s;
}
.modal .field .color-opt.selected { border-color: #333; }
.modal .modal-btns { display: flex; justify-content: flex-end; gap: 8px; margin-top: 16px; }
.modal .modal-btns button {
  padding: 6px 18px; border: 1px solid #bbb; border-radius: 4px;
  cursor: pointer; font-size: 0.9em;
}
.modal .modal-btns .btn-primary { background: var(--accent); color: #fff; border-color: var(--accent); }

/* View mode styles */
.view-mode #gantt-wrapper { border-radius: 0; margin: 0; }
.view-mode .gantt-task { border-radius: 5px; box-shadow: 0 1px 4px rgba(0,0,0,.15); }
.view-mode .body-cell { border-right-color: #f0f0f0; }
.view-mode .sidebar-btns { display: none !important; }

/* Toast */
#toast {
  position: fixed; bottom: 20px; left: 50%; transform: translateX(-50%);
  background: #333; color: #fff; padding: 10px 24px; border-radius: 6px;
  font-size: 0.9em; z-index: 400; display: none; box-shadow: 0 4px 12px rgba(0,0,0,.3);
}
#drag-tooltip {
  position: fixed; pointer-events: none; z-index: 500;
  background: rgba(0,0,0,.8); color: #fff; padding: 3px 8px; border-radius: 4px;
  font-size: 12px; white-space: nowrap; display: none;
  transform: translate(-50%, -130%);
}
</style>
</head>
<body>

<div id="toolbar">
  <div class="toolbar-group">
    <button id="btn-edit-mode" class="active" onclick="setMode('edit')"></button>
    <button id="btn-view-mode" onclick="setMode('view')"></button>
  </div>
  <div class="toolbar-sep"></div>
  <div class="toolbar-group">
    <label id="lbl-unit"></label>
    <select id="sel-unit" onchange="changeUnit(this.value)">
      <option value="month" selected id="opt-month"></option>
      <option value="week" id="opt-week"></option>
      <option value="day" id="opt-day"></option>
    </select>
  </div>
  <div class="toolbar-sep"></div>
  <div class="toolbar-group">
    <label id="lbl-font"></label>
    <button onclick="changeFontSize(-1)">A-</button>
    <button onclick="changeFontSize(1)">A+</button>
  </div>
  <div class="toolbar-sep"></div>
  <div class="toolbar-group" id="edit-controls">
    <button id="btn-add-col-start" onclick="addColumnStart()"></button>
    <button id="btn-add-col-end" onclick="addColumnEnd()"></button>
    <button id="btn-rm-col-start" onclick="removeColumnStart()"></button>
    <button id="btn-rm-col-end" onclick="removeColumnEnd()"></button>
    <button id="btn-add-row" onclick="addRow()"></button>
  </div>
  <div class="toolbar-group" id="thunder-controls">
    <div class="toolbar-sep"></div>
    <label><input type="checkbox" id="chk-arrows" checked onchange="toggleArrows(this.checked)"> <span id="lbl-arrows"></span></label>
    <label><input type="checkbox" id="chk-thunder" checked onchange="toggleThunder(this.checked)"> <span id="lbl-thunder"></span></label>
    <label><input type="checkbox" id="chk-progress-shading" onchange="toggleProgressShading(this.checked)"> <span id="lbl-progress-shading"></span></label>
    <label id="lbl-base-date"></label>
    <input type="date" id="thunder-default-date" onchange="changeThunderDefault(this.value)">
    <button id="btn-reset-progress" onclick="resetProgressPoints()"></button>
  </div>
  <div class="toolbar-group" id="range-controls">
    <div class="toolbar-sep"></div>
    <label id="lbl-range"></label>
    <input type="date" id="view-start" onchange="applyViewRange()">
    <span>~</span>
    <input type="date" id="view-end" onchange="applyViewRange()">
    <button id="btn-all-range" onclick="clearViewRange()"></button>
  </div>
  <div class="toolbar-group" id="view-controls" style="display:none;">
    <div class="toolbar-sep"></div>
    <button id="btn-copy-image" onclick="copyAsImage()"></button>
  </div>
  <div class="toolbar-sep"></div>
  <div class="toolbar-group">
    <button id="btn-export" onclick="exportJSON()"></button>
    <button id="btn-import" onclick="importJSON()"></button>
  </div>
  <div class="toolbar-sep"></div>
  <div class="toolbar-group">
    <select id="sel-lang" onchange="changeLang(this.value)">
      <option value="en">EN</option>
      <option value="ja">JA</option>
    </select>
  </div>
</div>

<div id="gantt-wrapper">
  <div id="sidebar-resize-handle"></div>
  <div id="body-height-resize-handle"></div>
  <div id="gantt-corner" contenteditable="true">Task</div>
  <div id="gantt-header-scroll"><div id="gantt-header"></div></div>
  <div id="gantt-sidebar-scroll"><div id="gantt-sidebar"></div></div>
  <div id="gantt-body-scroll">
    <div id="gantt-body">
      <div id="grid-layer"></div>
      <div id="items-layer"></div>
      <svg id="arrow-svg"></svg>
      <svg id="thunder-svg"></svg>
      <div id="gantt-resize-handle"></div>
    </div>
  </div>
</div>

<div id="context-menu"></div>
<div id="toast"></div>
<div id="drag-tooltip"></div>
<input type="file" id="file-input" accept=".json" style="display:none" onchange="handleFileImport(event)">

<script>
// ===== i18n =====
const I18N = {
  en: {
    title: 'Gantt Chart',
    taskName: 'Task',
    edit: 'Edit',
    view: 'View',
    unit: 'Unit:',
    month: 'Month',
    week: 'Week',
    day: 'Day',
    font: 'Font:',
    addColStart: '\u2190Col',
    addColEnd: 'Col\u2192',
    rmColStart: '\u2190Del',
    rmColEnd: 'Del\u2192',
    addRow: 'Add Row',
    thunderLine: 'Progress Line',
    baseDate: 'Base:',
    range: 'Range:',
    allRange: 'All',
    copyImage: 'Copy Image',
    export: 'Export',
    import: 'Import',
    cancel: 'Cancel',
    ok: 'OK',
    label: 'Label',
    startDate: 'Start',
    endDate: 'End',
    color: 'Color',
    labelPos: 'Label Position',
    posInside: 'Inside',
    posAbove: 'Above',
    posBelow: 'Below',
    posLeft: 'Left',
    posRight: 'Right',
    posBefore: 'Before',
    posAfter: 'After',
    date: 'Date',
    memo: 'Memo',
    milestoneShape: 'Shape',
    milestoneColor: 'Color',
    addTask: 'Add Task',
    addMilestone: 'Add Milestone',
    editTask: 'Edit Task',
    editMilestone: 'Edit Milestone',
    addProgress: 'Add Progress Point',
    deleteSelected: 'Delete Selected',
    deleteRow: 'Delete Row',
    addRowAbove: 'Add Row Above',
    deleteItem: 'Delete',
    editItem: 'Edit Task\u2026',
    editMilestoneItem: 'Edit Milestone\u2026',
    deleteProgress: 'Reset Progress (use base date)',
    resetAllProgress: 'Reset All',
    visibleInView: 'Visible in View mode',
    hiddenInView: 'Hidden in View mode',
    dragToReorder: 'Drag to reorder',
    unnamed: '(Unnamed)',
    newTask: 'New Task',
    exported: 'Exported',
    imported: 'Imported',
    imageCopied: 'Image copied to clipboard',
    imageDownloaded: 'Image downloaded',
    invalidFile: 'Invalid file format.',
    jsonError: 'Failed to load JSON: ',
    deleteArrow: 'Delete Arrow',
    arrows: 'Arrows',
    addLane: 'Add Lane',
    removeLane: 'Remove Lane',
    lane: 'Lane',
    editRow: 'Edit Row\u2026',
    rowColor: 'Row Color',
    rowMemo: 'Memo',
    noColor: 'None (default)',
    progressShading: 'Progress Shading',
    collapseRow: 'Collapse row',
    expandRow: 'Expand row',
  },
  ja: {
    title: '\u30AC\u30F3\u30C8\u30C1\u30E3\u30FC\u30C8',
    taskName: '\u30BF\u30B9\u30AF\u540D',
    edit: '\u7DE8\u96C6',
    view: '\u8868\u793A',
    unit: '\u5358\u4F4D:',
    month: '\u6708',
    week: '\u9031',
    day: '\u65E5',
    font: '\u6587\u5B57:',
    addColStart: '\u2190\u5217\u8FFD\u52A0',
    addColEnd: '\u5217\u8FFD\u52A0\u2192',
    rmColStart: '\u2190\u5217\u524A\u9664',
    rmColEnd: '\u5217\u524A\u9664\u2192',
    addRow: '\u884C\u8FFD\u52A0',
    thunderLine: '\u9032\u6357\u7DDA',
    baseDate: '\u57FA\u6E96\u65E5:',
    range: '\u671F\u9593:',
    allRange: '\u5168\u671F\u9593',
    copyImage: '\u753B\u50CF\u30B3\u30D4\u30FC',
    export: '\u30A8\u30AF\u30B9\u30DD\u30FC\u30C8',
    import: '\u30A4\u30F3\u30DD\u30FC\u30C8',
    cancel: '\u30AD\u30E3\u30F3\u30BB\u30EB',
    ok: 'OK',
    label: '\u30E9\u30D9\u30EB',
    startDate: '\u958B\u59CB\u65E5',
    endDate: '\u7D42\u4E86\u65E5',
    color: '\u8272',
    labelPos: '\u30E9\u30D9\u30EB\u4F4D\u7F6E',
    posInside: '\u4E2D',
    posAbove: '\u4E0A',
    posBelow: '\u4E0B',
    posLeft: '\u5DE6',
    posRight: '\u53F3',
    posBefore: '\u524D',
    posAfter: '\u5F8C',
    date: '\u65E5\u4ED8',
    memo: '\u30E1\u30E2',
    milestoneShape: '\u5F62\u72B6',
    milestoneColor: '\u8272',
    addTask: '\u4F5C\u696D\u3092\u8FFD\u52A0',
    addMilestone: '\u30A4\u30D9\u30F3\u30C8\u3092\u8FFD\u52A0',
    editTask: '\u4F5C\u696D\u3092\u7DE8\u96C6',
    editMilestone: '\u30A4\u30D9\u30F3\u30C8\u3092\u7DE8\u96C6',
    addProgress: '\u9032\u6357\u4F4D\u7F6E\u3092\u8FFD\u52A0',
    deleteSelected: '\u9078\u629E\u9805\u76EE\u3092\u524A\u9664',
    deleteRow: '\u884C\u524A\u9664',
    addRowAbove: '\u4E0A\u306B\u884C\u8FFD\u52A0',
    deleteItem: '\u524A\u9664',
    editItem: '\u4F5C\u696D\u3092\u7DE8\u96C6\u2026',
    editMilestoneItem: '\u30A4\u30D9\u30F3\u30C8\u3092\u7DE8\u96C6\u2026',
    deleteProgress: '\u9032\u6357\u4F4D\u7F6E\u3092\u524A\u9664\uFF08\u57FA\u6E96\u65E5\u306B\u623B\u3059\uFF09',
    resetAllProgress: '\u5168\u30EA\u30BB\u30C3\u30C8',
    visibleInView: '\u8868\u793A\u30E2\u30FC\u30C9\u3067\u8868\u793A',
    hiddenInView: '\u8868\u793A\u30E2\u30FC\u30C9\u3067\u975E\u8868\u793A',
    dragToReorder: '\u30C9\u30E9\u30C3\u30B0\u3067\u4E26\u3079\u66FF\u3048',
    unnamed: '(\u672A\u8A2D\u5B9A)',
    newTask: '\u65B0\u898F\u4F5C\u696D',
    exported: '\u30A8\u30AF\u30B9\u30DD\u30FC\u30C8\u3057\u307E\u3057\u305F',
    imported: '\u30A4\u30F3\u30DD\u30FC\u30C8\u3057\u307E\u3057\u305F',
    imageCopied: '\u753B\u50CF\u3092\u30AF\u30EA\u30C3\u30D7\u30DC\u30FC\u30C9\u306B\u30B3\u30D4\u30FC\u3057\u307E\u3057\u305F',
    imageDownloaded: '\u753B\u50CF\u3092\u30C0\u30A6\u30F3\u30ED\u30FC\u30C9\u3057\u307E\u3057\u305F',
    invalidFile: '\u7121\u52B9\u306A\u30D5\u30A1\u30A4\u30EB\u5F62\u5F0F\u3067\u3059\u3002',
    jsonError: 'JSON\u306E\u8AAD\u307F\u8FBC\u307F\u306B\u5931\u6557\u3057\u307E\u3057\u305F: ',
    deleteArrow: '\u77E2\u5370\u3092\u524A\u9664',
    arrows: '\u77E2\u5370',
    addLane: '\u30EC\u30FC\u30F3\u3092\u8FFD\u52A0',
    removeLane: '\u30EC\u30FC\u30F3\u3092\u524A\u9664',
    lane: '\u30EC\u30FC\u30F3',
    editRow: '\u884C\u3092\u7DE8\u96C6\u2026',
    rowColor: '\u884C\u306E\u8272',
    rowMemo: '\u30E1\u30E2',
    noColor: '\u306A\u3057\uFF08\u30C7\u30D5\u30A9\u30EB\u30C8\uFF09',
    progressShading: '\u9032\u6357\u8868\u793A',
    collapseRow: '\u884C\u3092\u6298\u308A\u305F\u305F\u3080',
    expandRow: '\u884C\u3092\u5C55\u958B\u3059\u308B',
  }
};

let currentLang = 'en';

function t(key) {
  return (I18N[currentLang] && I18N[currentLang][key]) || I18N.en[key] || key;
}

function updateUIText() {
  document.title = t('title');
  document.documentElement.lang = currentLang;
  document.getElementById('btn-edit-mode').textContent = t('edit');
  document.getElementById('btn-view-mode').textContent = t('view');
  document.getElementById('lbl-unit').textContent = t('unit');
  document.getElementById('opt-month').textContent = t('month');
  document.getElementById('opt-week').textContent = t('week');
  document.getElementById('opt-day').textContent = t('day');
  document.getElementById('lbl-font').textContent = t('font');
  document.getElementById('btn-add-col-start').textContent = t('addColStart');
  document.getElementById('btn-add-col-end').textContent = t('addColEnd');
  document.getElementById('btn-rm-col-start').textContent = t('rmColStart');
  document.getElementById('btn-rm-col-end').textContent = t('rmColEnd');
  document.getElementById('btn-add-row').textContent = t('addRow');
  document.getElementById('lbl-arrows').textContent = t('arrows');
  document.getElementById('lbl-thunder').textContent = t('thunderLine');
  document.getElementById('lbl-progress-shading').textContent = t('progressShading');
  document.getElementById('btn-reset-progress').textContent = t('resetAllProgress');
  document.getElementById('lbl-base-date').textContent = t('baseDate');
  document.getElementById('lbl-range').textContent = t('range');
  document.getElementById('btn-all-range').textContent = t('allRange');
  document.getElementById('btn-copy-image').textContent = t('copyImage');
  document.getElementById('btn-export').textContent = t('export');
  document.getElementById('btn-import').textContent = t('import');
  const corner = document.getElementById('gantt-corner');
  corner.textContent = state.cornerLabel || t('taskName');
}

function changeLang(lang) {
  currentLang = lang;
  state.lang = lang;
  document.getElementById('sel-lang').value = lang;
  updateUIText();
  render();
}

// ===== State =====
const _now = new Date();
const _initStart = new Date(_now.getFullYear(), _now.getMonth() - 1, 1);
const _initEnd = new Date(_now.getFullYear(), _now.getMonth() + 2, 0);
let state = {
  lang: 'en',
  timeUnit: 'month',
  startDate: fmtDate(_initStart),
  endDate: fmtDate(_initEnd),
  fontSize: 14,
  cornerLabel: '',
  sidebarWidth: 180,
  colWidth: null,
  bodyHeight: null,
  viewRange: null,
  rows: [
    { name: 'Task 1', items: [], lanes: 1 },
    { name: 'Task 2', items: [], lanes: 1 },
    { name: 'Task 3', items: [], lanes: 1 }
  ],
  thunderLine: { visible: true, points: [], defaultDate: fmtDate(new Date()) },
  arrowsVisible: true,
  arrows: [],
  progressShading: false
};

let appMode = 'edit'; // edit | view
let viewRange = null; // {start, end}
let selectedItems = []; // [{rowIndex, itemIndex}]

// ===== Undo Stack =====
const undoStack = [];
const MAX_UNDO = 50;

function pushUndo(action) {
  if (undoStack.length >= MAX_UNDO) undoStack.shift();
  undoStack.push(action);
}

function undo() {
  if (undoStack.length === 0) return;
  const action = undoStack.pop();
  switch (action.type) {
    case 'moveItems':
      action.items.forEach(a => {
        const item = state.rows[a.rowIndex].items[a.itemIndex];
        if (a.startDate !== undefined) item.startDate = a.startDate;
        if (a.endDate !== undefined) item.endDate = a.endDate;
        if (a.date !== undefined) item.date = a.date;
      });
      break;
    case 'resizeItem': {
      const item = state.rows[action.rowIndex].items[action.itemIndex];
      item.startDate = action.startDate;
      item.endDate = action.endDate;
      break;
    }
    case 'addArrow':
      state.arrows.splice(action.arrowIndex, 1);
      break;
    case 'moveThunderDot':
      if (action.wasNew) {
        state.thunderLine.points.splice(action.pointIndex, 1);
      } else {
        state.thunderLine.points[action.pointIndex].date = action.oldDate;
      }
      break;
  }
  render();
}
let columns = [];
let colWidth = 80;
let customColWidth = null; // user-set column width via drag resize
let customBodyHeight = null; // user-set body height via drag resize
let isDragging = false;
let dragData = null;

const COLORS = ['#4CAF50','#2196F3','#FF9800','#9C27B0','#F44336','#00BCD4','#795548','#607D8B','#E91E63','#3F51B5'];
const ROW_COLORS = [null,'#E3F2FD','#E8F5E9','#FFF3E0','#FCE4EC','#F3E5F5','#FFFDE7','#E0F2F1','#EFEBE9'];

// ===== Date Utils =====
function parseDate(s) { const p = s.split('-'); return new Date(+p[0], +p[1]-1, +p[2]); }
function fmtDate(d) { return `${d.getFullYear()}-${String(d.getMonth()+1).padStart(2,'0')}-${String(d.getDate()).padStart(2,'0')}`; }
function addDays(d, n) { const r = new Date(d); r.setDate(r.getDate()+n); return r; }
function daysBetween(a, b) { return Math.round((b.getTime()-a.getTime())/86400000); }
function monthStart(d) { return new Date(d.getFullYear(), d.getMonth(), 1); }
function monthEnd(d) { return new Date(d.getFullYear(), d.getMonth()+1, 0); }
function weekStart(d) { const r = new Date(d); const day = r.getDay(); r.setDate(r.getDate() - (day === 0 ? 6 : day - 1)); return r; }
function minDate(a,b) { return a < b ? a : b; }
function maxDate(a,b) { return a > b ? a : b; }

// ===== Column Generation =====
function generateColumns(start, end, unit) {
  const cols = [];
  const sd = parseDate(start), ed = parseDate(end);
  if (unit === 'month') {
    let cur = monthStart(sd);
    while (cur <= ed) {
      const mEnd = monthEnd(cur);
      cols.push({ start: new Date(cur), end: mEnd, label: String(cur.getMonth()+1), year: cur.getFullYear() });
      cur = new Date(cur.getFullYear(), cur.getMonth()+1, 1);
    }
  } else if (unit === 'week') {
    let cur = weekStart(sd);
    while (cur <= ed) {
      const wEnd = addDays(cur, 6);
      cols.push({ start: new Date(cur), end: wEnd, label: `${cur.getMonth()+1}/${cur.getDate()}`, year: cur.getFullYear() });
      cur = addDays(cur, 7);
    }
  } else {
    let cur = new Date(sd);
    while (cur <= ed) {
      const dow = cur.getDay();
      cols.push({ start: new Date(cur), end: new Date(cur), label: `${cur.getMonth()+1}/${cur.getDate()}`, year: cur.getFullYear(), weekend: dow === 0 || dow === 6 });
      cur = addDays(cur, 1);
    }
  }
  return cols;
}

// Returns the LEFT edge position of the given date's slot within its column
function getXForDate(date, cols, cw) {
  const d = (typeof date === 'string') ? parseDate(date) : date;
  for (let i = 0; i < cols.length; i++) {
    if (d >= cols[i].start && d <= cols[i].end) {
      const totalDays = daysBetween(cols[i].start, cols[i].end) + 1;
      const off = daysBetween(cols[i].start, d);
      return i * cw + (off / totalDays) * cw;
    }
  }
  if (d < cols[0].start) return 0;
  return cols.length * cw;
}

// Returns the RIGHT edge position of the given date's slot
function getXForDateEnd(date, cols, cw) {
  const d = (typeof date === 'string') ? parseDate(date) : date;
  for (let i = 0; i < cols.length; i++) {
    if (d >= cols[i].start && d <= cols[i].end) {
      const totalDays = daysBetween(cols[i].start, cols[i].end) + 1;
      const off = daysBetween(cols[i].start, d);
      return i * cw + ((off + 1) / totalDays) * cw;
    }
  }
  if (d < cols[0].start) return 0;
  return cols.length * cw;
}

// Returns the CENTER position of the given date's slot (for milestones, thunder points)
function getXForDateCenter(date, cols, cw) {
  return (getXForDate(date, cols, cw) + getXForDateEnd(date, cols, cw)) / 2;
}

function getDateForX(x, cols, cw) {
  const ci = Math.floor(x / cw);
  if (ci < 0) return new Date(cols[0].start);
  if (ci >= cols.length) return new Date(cols[cols.length-1].end);
  const col = cols[ci];
  const off = x - ci * cw;
  const totalDays = daysBetween(col.start, col.end) + 1;
  const dayOff = Math.floor((off / cw) * totalDays);
  return addDays(col.start, Math.max(0, Math.min(dayOff, totalDays - 1)));
}

// ===== Rendering =====
let isRendering = false;
function render() {
  if (isRendering) return;
  isRendering = true;
  const sd = viewRange ? viewRange.start : state.startDate;
  const ed = viewRange ? viewRange.end : state.endDate;
  columns = generateColumns(sd, ed, state.timeUnit);

  // Column width: use custom value if set, otherwise default
  if (customColWidth !== null) {
    colWidth = customColWidth;
  } else {
    const bodyScroll = document.getElementById('gantt-body-scroll');
    if (appMode === 'view' && viewRange) {
      const avail = bodyScroll.clientWidth || (window.innerWidth - parseInt(getComputedStyle(document.documentElement).getPropertyValue('--sidebar-width')) - 30);
      colWidth = Math.max(30, Math.floor(avail / columns.length));
    } else {
      colWidth = state.timeUnit === 'day' ? 36 : (state.timeUnit === 'week' ? 52 : 80);
    }
  }

  document.documentElement.style.setProperty('--col-width', colWidth + 'px');
  document.documentElement.style.setProperty('--font-size', state.fontSize + 'px');

  visibleRows = getVisibleRows();
  computeRowLayout();
  renderHeader();
  renderSidebar();
  measureSidebarRowHeights();
  applyCustomBodyHeight();
  // Set wrapper height when custom body height is set
  const wrapper = document.getElementById('gantt-wrapper');
  if (customBodyHeight !== null) {
    const hh = parseInt(getComputedStyle(document.documentElement).getPropertyValue('--header-height'));
    wrapper.style.height = (totalBodyHeight + hh) + 'px';
  } else {
    wrapper.style.height = '';
  }
  renderBody();
  renderItems();
  renderArrows();
  renderThunderLine();
  isRendering = false;
}

const BASE_ROW_HEIGHT = 44;
let rowHeights = []; // per visible row
let rowYOffsets = []; // cumulative Y for each visible row
let totalBodyHeight = 0;

const COLLAPSED_ROW_HEIGHT = 20;

function computeRowLayout() {
  const labelExtra = Math.ceil(state.fontSize * 0.8) + 4;
  rowHeights = [];
  rowYOffsets = [];
  let y = 0;
  visibleRows.forEach((entry, vi) => {
    if (entry.row.collapsed) {
      rowHeights.push(COLLAPSED_ROW_HEIGHT);
      rowYOffsets.push(y);
      y += COLLAPSED_ROW_HEIGHT;
      return;
    }
    let hasAbove = false, hasBelow = false;
    entry.row.items.forEach(item => {
      if (item.type === 'task') {
        const pos = item.taskLabelPosition || 'inside';
        if (pos === 'above') hasAbove = true;
        if (pos === 'below') hasBelow = true;
      }
    });
    const numLanes = entry.row.lanes || 1;
    const h = BASE_ROW_HEIGHT * numLanes + (hasAbove ? labelExtra : 0) + (hasBelow ? labelExtra : 0);
    rowHeights.push(h);
    rowYOffsets.push(y);
    y += h;
  });
  totalBodyHeight = y;
}

function getLaneCenterY(row, laneIndex, rh) {
  const numLanes = row.lanes || 1;
  const labelExtra = Math.ceil(state.fontSize * 0.8) + 4;
  let hasAbove = false;
  row.items.forEach(item => {
    if (item.type === 'task' && (item.taskLabelPosition || 'inside') === 'above') hasAbove = true;
  });
  const extraTop = hasAbove ? labelExtra : 0;
  let hasBelow = false;
  row.items.forEach(item => {
    if (item.type === 'task' && (item.taskLabelPosition || 'inside') === 'below') hasBelow = true;
  });
  const extraBottom = hasBelow ? labelExtra : 0;
  const laneH = (rh - extraTop - extraBottom) / numLanes;
  return extraTop + laneH * laneIndex + laneH / 2;
}

function getLaneForY(row, yWithinRow, rh) {
  const numLanes = row.lanes || 1;
  if (numLanes <= 1) return 0;
  const labelExtra = Math.ceil(state.fontSize * 0.8) + 4;
  let hasAbove = false;
  row.items.forEach(item => {
    if (item.type === 'task' && (item.taskLabelPosition || 'inside') === 'above') hasAbove = true;
  });
  const extraTop = hasAbove ? labelExtra : 0;
  let hasBelow = false;
  row.items.forEach(item => {
    if (item.type === 'task' && (item.taskLabelPosition || 'inside') === 'below') hasBelow = true;
  });
  const extraBottom = hasBelow ? labelExtra : 0;
  const laneH = (rh - extraTop - extraBottom) / numLanes;
  const laneIndex = Math.floor((yWithinRow - extraTop) / laneH);
  return Math.max(0, Math.min(numLanes - 1, laneIndex));
}

function getVisibleRowIndexForY(y) {
  for (let i = 0; i < visibleRows.length; i++) {
    if (y < rowYOffsets[i] + rowHeights[i]) return i;
  }
  return visibleRows.length - 1;
}

// Returns array of {row, originalIndex} for rows to display
function getVisibleRows() {
  if (appMode === 'edit') {
    return state.rows.map((r, i) => ({ row: r, originalIndex: i }));
  }
  return state.rows
    .map((r, i) => ({ row: r, originalIndex: i }))
    .filter(entry => entry.row.visible !== false && !entry.row.collapsed);
}

let visibleRows = [];

function renderHeader() {
  const hdr = document.getElementById('gantt-header');
  hdr.innerHTML = '';
  hdr.style.width = (columns.length * colWidth) + 'px';
  let prevYear = null;
  columns.forEach((col, i) => {
    const cell = document.createElement('div');
    cell.className = 'header-cell';
    if (col.year !== prevYear && i > 0) cell.classList.add('year-start');
    if (col.weekend) cell.classList.add('weekend');
    cell.style.flexBasis = colWidth + 'px';
    cell.style.minWidth = colWidth + 'px';
    let lbl = col.label;
    if (col.year !== prevYear) {
      if (state.timeUnit === 'month') lbl = col.year + '/' + lbl;
      prevYear = col.year;
    }
    cell.textContent = lbl;
    hdr.appendChild(cell);
  });
}

function measureSidebarRowHeights() {
  const sb = document.getElementById('gantt-sidebar');
  const sidebarRows = sb.querySelectorAll('.sidebar-row');
  let y = 0;
  sidebarRows.forEach((el, i) => {
    if (visibleRows[i] && visibleRows[i].row.collapsed) {
      // Keep collapsed rows at fixed height, don't let content expand them
      el.style.height = COLLAPSED_ROW_HEIGHT + 'px';
      rowHeights[i] = COLLAPSED_ROW_HEIGHT;
    } else {
      const naturalH = el.offsetHeight;
      if (naturalH > rowHeights[i]) {
        rowHeights[i] = naturalH;
      }
      el.style.height = rowHeights[i] + 'px';
    }
    rowYOffsets[i] = y;
    y += rowHeights[i];
  });
  totalBodyHeight = y;
}

function applyCustomBodyHeight() {
  if (customBodyHeight === null || visibleRows.length === 0) return;
  const naturalTotal = totalBodyHeight;
  if (naturalTotal <= 0) return;
  const targetH = Math.max(visibleRows.length * 20, customBodyHeight);
  const scale = targetH / naturalTotal;
  const sb = document.getElementById('gantt-sidebar');
  const sidebarRows = sb.querySelectorAll('.sidebar-row');

  // Apply scaled heights to sidebar rows (keep collapsed rows fixed)
  for (let i = 0; i < rowHeights.length; i++) {
    if (visibleRows[i] && visibleRows[i].row.collapsed) {
      rowHeights[i] = COLLAPSED_ROW_HEIGHT;
    } else {
      rowHeights[i] = Math.round(rowHeights[i] * scale);
    }
    if (sidebarRows[i]) sidebarRows[i].style.height = rowHeights[i] + 'px';
  }

  // Re-measure: sidebar rows may not shrink below their content
  // Use the actual rendered height as the floor
  let y = 0;
  for (let i = 0; i < rowHeights.length; i++) {
    if (visibleRows[i] && visibleRows[i].row.collapsed) {
      rowHeights[i] = COLLAPSED_ROW_HEIGHT;
    } else if (sidebarRows[i]) {
      const actual = sidebarRows[i].offsetHeight;
      if (actual > rowHeights[i]) {
        rowHeights[i] = actual;
      }
    }
    rowYOffsets[i] = y;
    y += rowHeights[i];
  }
  totalBodyHeight = y;
}

function renderSidebar() {
  const sb = document.getElementById('gantt-sidebar');
  sb.innerHTML = '';

  if (appMode === 'edit') {
    // Edit mode
    state.rows.forEach((row, ri) => {
      // In edit mode visibleRows = all rows, so vi === ri
      const div = document.createElement('div');
      div.className = 'sidebar-row';
      if (!row.collapsed) div.style.minHeight = rowHeights[ri] + 'px';
      div.dataset.rowIndex = ri;
      if (row.color) div.style.background = row.color;

      const collapseBtn = document.createElement('span');
      collapseBtn.className = 'sidebar-collapse-btn';
      collapseBtn.textContent = row.collapsed ? '▶' : '▼';
      collapseBtn.title = row.collapsed ? t('expandRow') : t('collapseRow');
      collapseBtn.onclick = () => {
        state.rows[ri].collapsed = !state.rows[ri].collapsed;
        render();
      };
      div.appendChild(collapseBtn);

      const handle = document.createElement('span');
      handle.className = 'sidebar-drag-handle';
      handle.textContent = '☰';
      handle.title = t('dragToReorder');
      handle.addEventListener('mousedown', e => startRowDrag(e, ri));
      div.appendChild(handle);

      if (row.collapsed) {
        div.classList.add('row-collapsed');
        div.style.height = COLLAPSED_ROW_HEIGHT + 'px';
        div.style.maxHeight = COLLAPSED_ROW_HEIGHT + 'px';
        div.style.minHeight = '';
      }

      const nameEl = document.createElement('span');
      nameEl.className = 'sidebar-name';
      nameEl.textContent = row.name;
      nameEl.contentEditable = true;
      nameEl.addEventListener('blur', () => {
        if (isRendering || !nameEl.isConnected) return;
        state.rows[ri].name = nameEl.innerText.trim() || t('unnamed');
        render();
      });
      nameEl.addEventListener('keydown', e => {
        if (e.key === 'Enter' && !e.shiftKey) { e.preventDefault(); nameEl.blur(); }
      });
      if (row.memo) nameEl.title = row.memo;
      div.appendChild(nameEl);

      const btns = document.createElement('div');
      btns.className = 'sidebar-btns';
      const btnDel = document.createElement('button');
      btnDel.textContent = '×';
      btnDel.title = t('deleteRow');
      btnDel.onclick = () => { if(state.rows.length>1){ deleteRowAt(ri); } };
      const btnUp = document.createElement('button');
      btnUp.textContent = '↑';
      btnUp.title = t('addRowAbove');
      btnUp.onclick = () => { insertRowAt(ri); };
      btns.appendChild(btnUp);
      btns.appendChild(btnDel);
      div.appendChild(btns);

      div.addEventListener('contextmenu', (e) => {
        e.preventDefault();
        showContextMenu(e.clientX, e.clientY, [
          { label: t('editRow'), action: () => editRowDialog(ri) },
          { sep: true },
          { label: t('addRowAbove'), action: () => insertRowAt(ri) },
          { label: t('deleteRow'), action: () => { if(state.rows.length>1) deleteRowAt(ri); } },
        ]);
      });

      sb.appendChild(div);
    });
  } else {
    // View mode: show only visible rows
    visibleRows.forEach((entry, vi) => {
      const div = document.createElement('div');
      div.className = 'sidebar-row';
      div.style.minHeight = rowHeights[vi] + 'px';
      if (entry.row.color) div.style.background = entry.row.color;
      const nameEl = document.createElement('span');
      nameEl.className = 'sidebar-name';
      nameEl.textContent = entry.row.name;
      nameEl.contentEditable = false;
      if (entry.row.memo) nameEl.title = entry.row.memo;
      div.appendChild(nameEl);
      sb.appendChild(div);
    });
  }
}

// ===== Row Drag & Drop =====
function startRowDrag(e, fromIndex) {
  e.preventDefault();
  e.stopPropagation();
  // Commit any in-progress name editing before dragging
  if (document.activeElement && document.activeElement.isContentEditable) {
    document.activeElement.blur();
  }
  const sb = document.getElementById('gantt-sidebar');
  const rows = sb.querySelectorAll('.sidebar-row');
  let targetIndex = fromIndex;

  rows[fromIndex].classList.add('dragging');

  function onMove(ev) {
    // Clear all indicators
    rows.forEach(r => { r.classList.remove('drag-over-above', 'drag-over-below'); });

    // Find which row the mouse is over
    const sbRect = sb.getBoundingClientRect();
    const sidebarScroll = document.getElementById('gantt-sidebar-scroll');
    const y = ev.clientY - sbRect.top + sidebarScroll.scrollTop;
    let hoverIndex = getVisibleRowIndexForY(y);
    hoverIndex = Math.max(0, Math.min(hoverIndex, state.rows.length - 1));

    if (hoverIndex === fromIndex) {
      targetIndex = fromIndex;
      return;
    }

    // Show indicator
    if (hoverIndex < fromIndex) {
      // Moving up: drop above the hovered row
      rows[hoverIndex].classList.add('drag-over-above');
      targetIndex = hoverIndex;
    } else {
      // Moving down: drop below the hovered row
      rows[hoverIndex].classList.add('drag-over-below');
      targetIndex = hoverIndex;
    }
  }

  function onUp() {
    document.removeEventListener('mousemove', onMove);
    document.removeEventListener('mouseup', onUp);
    rows.forEach(r => { r.classList.remove('dragging', 'drag-over-above', 'drag-over-below'); });

    if (targetIndex !== fromIndex) {
      moveRow(fromIndex, targetIndex);
    }
  }

  document.addEventListener('mousemove', onMove);
  document.addEventListener('mouseup', onUp);
}

function moveRow(from, to) {
  // Move the row in state.rows
  const row = state.rows.splice(from, 1)[0];
  state.rows.splice(to, 0, row);

  // Update thunder line point indices
  state.thunderLine.points.forEach(p => {
    if (p.rowIndex === from) {
      p.rowIndex = to;
    } else if (from < to) {
      // Moved down: rows between (from, to] shift up by 1
      if (p.rowIndex > from && p.rowIndex <= to) p.rowIndex--;
    } else {
      // Moved up: rows between [to, from) shift down by 1
      if (p.rowIndex >= to && p.rowIndex < from) p.rowIndex++;
    }
  });

  updateArrowsForMove(from, to);

  // Update selected items indices
  selectedItems = selectedItems.map(s => {
    let newRi = s.rowIndex;
    if (s.rowIndex === from) {
      newRi = to;
    } else if (from < to) {
      if (s.rowIndex > from && s.rowIndex <= to) newRi--;
    } else {
      if (s.rowIndex >= to && s.rowIndex < from) newRi++;
    }
    return { rowIndex: newRi, itemIndex: s.itemIndex };
  });

  render();
}

function renderBody() {
  const grid = document.getElementById('grid-layer');
  grid.innerHTML = '';
  const totalW = columns.length * colWidth;
  const body = document.getElementById('gantt-body');
  body.style.width = totalW + 'px';
  body.style.height = totalBodyHeight + 'px';

  // Position resize handle at right edge of last column
  const resizeHandle = document.getElementById('gantt-resize-handle');
  resizeHandle.style.left = (totalW - 4) + 'px';
  let prevYear = null;
  visibleRows.forEach((entry, vi) => {
    const rowDiv = document.createElement('div');
    rowDiv.className = 'body-row';
    rowDiv.style.height = rowHeights[vi] + 'px';
    if (entry.row.color) rowDiv.style.background = entry.row.color;
    prevYear = null;
    columns.forEach((col, ci) => {
      const cell = document.createElement('div');
      cell.className = 'body-cell';
      cell.style.flexBasis = colWidth + 'px';
      cell.style.minWidth = colWidth + 'px';
      if (col.year !== prevYear && ci > 0) cell.classList.add('year-start');
      if (col.weekend) cell.classList.add('weekend');
      prevYear = col.year;
      rowDiv.appendChild(cell);
    });
    grid.appendChild(rowDiv);
  });

  // Lane separator lines
  visibleRows.forEach((entry, vi) => {
    if (entry.row.collapsed) return;
    const numLanes = entry.row.lanes || 1;
    if (numLanes <= 1) return;
    const rh = rowHeights[vi];
    const ry = rowYOffsets[vi];
    const labelExtra = Math.ceil(state.fontSize * 0.8) + 4;
    let hasAbove = false, hasBelow = false;
    entry.row.items.forEach(item => {
      if (item.type === 'task') {
        const pos = item.taskLabelPosition || 'inside';
        if (pos === 'above') hasAbove = true;
        if (pos === 'below') hasBelow = true;
      }
    });
    const extraTop = hasAbove ? labelExtra : 0;
    const extraBottom = hasBelow ? labelExtra : 0;
    const laneH = (rh - extraTop - extraBottom) / numLanes;
    for (let li = 1; li < numLanes; li++) {
      const sepY = ry + extraTop + laneH * li;
      const sep = document.createElement('div');
      sep.className = 'lane-separator';
      sep.style.top = sepY + 'px';
      sep.style.width = totalW + 'px';
      grid.appendChild(sep);
    }
  });
}

function renderItems() {
  const layer = document.getElementById('items-layer');
  layer.innerHTML = '';
  const bh = parseInt(getComputedStyle(document.documentElement).getPropertyValue('--bar-height'));

  visibleRows.forEach((entry, vi) => {
    if (entry.row.collapsed) return; // skip collapsed rows
    const ri = entry.originalIndex;
    const rh = rowHeights[vi];
    const ry = rowYOffsets[vi];
    entry.row.items.forEach((item, ii) => {
      if (item.type === 'task') {
        renderTask(layer, item, ri, ii, rh, bh, ry);
      } else if (item.type === 'milestone') {
        renderMilestone(layer, item, ri, ii, rh, ry);
      }
    });
  });
}

function renderTask(layer, item, ri, ii, rh, bh, ry) {
  const x1 = getXForDate(item.startDate, columns, colWidth);
  const x2 = getXForDateEnd(item.endDate, columns, colWidth);
  if (x2 < 0 || x1 > columns.length * colWidth) return;
  const w = Math.max(x2 - x1, 6);
  const row = state.rows[ri];
  const laneIdx = item.lane || 0;
  const laneCenter = getLaneCenterY(row, laneIdx, rh);
  const top = ry + laneCenter - bh / 2;

  const el = document.createElement('div');
  el.className = 'gantt-item gantt-task';
  if (isSelected(ri, ii)) el.classList.add('selected');
  el.style.left = x1 + 'px';
  el.style.top = top + 'px';
  el.style.width = w + 'px';
  el.style.background = item.color || COLORS[0];
  const lblPos = item.taskLabelPosition || 'inside';
  if (lblPos !== 'inside') el.style.overflow = 'visible';
  let taskLabel;
  if (lblPos === 'inside') {
    taskLabel = document.createElement('span');
    taskLabel.className = 'task-label';
    taskLabel.textContent = item.label || '';
    el.appendChild(taskLabel);
  } else {
    taskLabel = document.createElement('span');
    taskLabel.className = 'task-label-outside pos-' + lblPos;
    taskLabel.textContent = item.label || '';
    el.appendChild(taskLabel);
  }
  el.title = `${item.label || ''}\n${item.startDate} 〜 ${item.endDate}${item.memo ? '\n' + item.memo : ''}`;

  // Progress shading overlay
  const progressDate = getProgressDateForLane(ri, item.lane || 0);
  if (progressDate) {
    const taskStart = parseDate(item.startDate), taskEnd = parseDate(item.endDate);
    const progD = parseDate(progressDate);
    const totalDays = daysBetween(taskStart, taskEnd);
    if (totalDays > 0) {
      const elapsed = daysBetween(taskStart, progD);
      const pct = Math.max(0, Math.min(100, elapsed / totalDays * 100));
      if (pct > 0) {
        const overlay = document.createElement('div');
        overlay.style.cssText = `position:absolute;top:0;left:0;width:${pct}%;height:100%;background:rgba(0,0,0,0.15);border-radius:${pct >= 100 ? '4px' : '4px 0 0 4px'};pointer-events:none;`;
        el.appendChild(overlay);
      }
    }
  }

  if (appMode === 'edit') {
    const lHandle = document.createElement('div');
    lHandle.className = 'resize-handle left';
    lHandle.addEventListener('mousedown', e => startResize(e, ri, ii, 'left'));
    el.appendChild(lHandle);
    const rHandle = document.createElement('div');
    rHandle.className = 'resize-handle right';
    rHandle.addEventListener('mousedown', e => startResize(e, ri, ii, 'right'));
    el.appendChild(rHandle);

    // Arrow anchors
    if (state.arrowsVisible !== false) {
      const leftAnchor = document.createElement('div');
      leftAnchor.className = 'arrow-anchor';
      leftAnchor.style.left = '0px';
      leftAnchor.style.top = (bh / 2) + 'px';
      leftAnchor.addEventListener('mousedown', e => { e.stopPropagation(); e.preventDefault(); startArrowDrag(e, ri, ii, 'left'); });
      el.appendChild(leftAnchor);
      const rightAnchor = document.createElement('div');
      rightAnchor.className = 'arrow-anchor';
      rightAnchor.style.left = w + 'px';
      rightAnchor.style.top = (bh / 2) + 'px';
      rightAnchor.addEventListener('mousedown', e => { e.stopPropagation(); e.preventDefault(); startArrowDrag(e, ri, ii, 'right'); });
      el.appendChild(rightAnchor);
    }

    el.addEventListener('mousedown', e => {
      if (e.target.classList.contains('resize-handle') || e.target.classList.contains('arrow-anchor')) return;
      if (el.querySelector('.inline-edit')) return;
      onItemMouseDown(e, ri, ii);
    });
    el.addEventListener('contextmenu', e => {
      e.preventDefault(); e.stopPropagation();
      showContextMenu(e.clientX, e.clientY, [
        { label: t('editItem'), action: () => editItemDialog(ri, ii) },
        { label: t('deleteItem'), action: () => { removeArrowsForItem(ri, ii); state.rows[ri].items.splice(ii, 1); selectedItems = []; render(); } }
      ]);
    });
  }
  layer.appendChild(el);
}

function renderMilestone(layer, item, ri, ii, rh, ry) {
  const x = getXForDateCenter(item.date, columns, colWidth);
  if (x < 0 || x > columns.length * colWidth) return;
  const row = state.rows[ri];
  const laneIdx = item.lane || 0;
  const laneCenter = getLaneCenterY(row, laneIdx, rh);
  const top = ry + laneCenter;

  const el = document.createElement('div');
  el.className = 'gantt-item gantt-milestone';
  if (isSelected(ri, ii)) el.classList.add('selected');
  el.style.top = (top - 12) + 'px';
  el.title = `${item.label || ''}\n${item.date}${item.memo ? '\n' + item.memo : ''}`;

  const pos = item.labelPosition || 'after';
  let lblEl;
  if (pos === 'before') {
    lblEl = document.createElement('span');
    lblEl.className = 'milestone-label';
    lblEl.textContent = item.label || '';
    el.appendChild(lblEl);
  }
  const mark = document.createElement('span');
  mark.className = 'milestone-mark';
  mark.textContent = item.milestoneShape || '▽';
  if (item.milestoneColor) mark.style.color = item.milestoneColor;
  el.appendChild(mark);
  if (pos === 'after') {
    lblEl = document.createElement('span');
    lblEl.className = 'milestone-label';
    lblEl.textContent = item.label || '';
    el.appendChild(lblEl);
  }

  // Position: center the mark on x
  el.style.left = (x - 8) + 'px';

  if (appMode === 'edit') {
    // Arrow anchor for milestone
    if (state.arrowsVisible !== false) {
      const msAnchor = document.createElement('div');
      msAnchor.className = 'arrow-anchor';
      msAnchor.style.left = '8px';
      msAnchor.style.top = '12px';
      msAnchor.addEventListener('mousedown', e => { e.stopPropagation(); e.preventDefault(); startArrowDrag(e, ri, ii, 'center'); });
      el.appendChild(msAnchor);
    }

    el.addEventListener('mousedown', e => {
      if (e.target.classList.contains('arrow-anchor')) return;
      if (el.querySelector('.inline-edit')) return;
      onItemMouseDown(e, ri, ii);
    });
    el.addEventListener('contextmenu', e => {
      e.preventDefault(); e.stopPropagation();
      showContextMenu(e.clientX, e.clientY, [
        { label: t('editMilestoneItem'), action: () => editItemDialog(ri, ii) },
        { label: t('deleteItem'), action: () => { removeArrowsForItem(ri, ii); state.rows[ri].items.splice(ii, 1); selectedItems = []; render(); } }
      ]);
    });
  }
  layer.appendChild(el);
}

// ===== Arrow (Dependency) Rendering =====
function getArrowAnchorPos(ref) {
  const bh = parseInt(getComputedStyle(document.documentElement).getPropertyValue('--bar-height'));
  // Find visible row index for this originalIndex
  const vi = visibleRows.findIndex(e => e.originalIndex === ref.rowIndex);
  if (vi < 0) return null;
  const row = state.rows[ref.rowIndex];
  if (!row || !row.items[ref.itemIndex]) return null;
  const item = row.items[ref.itemIndex];
  const rh = rowHeights[vi];
  const ry = rowYOffsets[vi];
  const laneIdx = item.lane || 0;
  const laneCenter = getLaneCenterY(row, laneIdx, rh);

  if (item.type === 'task') {
    const y = ry + laneCenter;
    if (ref.edge === 'left') {
      return { x: getXForDate(item.startDate, columns, colWidth), y };
    } else {
      return { x: getXForDateEnd(item.endDate, columns, colWidth), y };
    }
  } else if (item.type === 'milestone') {
    return { x: getXForDateCenter(item.date, columns, colWidth), y: ry + laneCenter };
  }
  return null;
}

function renderArrows() {
  const svg = document.getElementById('arrow-svg');
  const totalW = columns.length * colWidth;
  svg.setAttribute('width', totalW);
  svg.setAttribute('height', totalBodyHeight);
  svg.innerHTML = '';

  if (state.arrowsVisible === false) return;

  // Define arrowhead marker
  const defs = document.createElementNS('http://www.w3.org/2000/svg', 'defs');
  const marker = document.createElementNS('http://www.w3.org/2000/svg', 'marker');
  marker.setAttribute('id', 'arrowhead');
  marker.setAttribute('markerWidth', '8');
  marker.setAttribute('markerHeight', '6');
  marker.setAttribute('refX', '8');
  marker.setAttribute('refY', '3');
  marker.setAttribute('orient', 'auto');
  const polygon = document.createElementNS('http://www.w3.org/2000/svg', 'polygon');
  polygon.setAttribute('points', '0 0, 8 3, 0 6');
  polygon.setAttribute('fill', '#666');
  marker.appendChild(polygon);
  defs.appendChild(marker);
  svg.appendChild(defs);

  if (!state.arrows || state.arrows.length === 0) return;

  state.arrows.forEach((arrow, ai) => {
    const fromPos = getArrowAnchorPos(arrow.from);
    const toPos = getArrowAnchorPos(arrow.to);
    if (!fromPos || !toPos) return;

    const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
    const d = buildArrowPath(fromPos, toPos);
    path.setAttribute('d', d);
    path.setAttribute('stroke', '#666');
    path.setAttribute('stroke-width', '1.5');
    path.setAttribute('fill', 'none');
    path.setAttribute('marker-end', 'url(#arrowhead)');

    if (appMode === 'edit') {
      path.addEventListener('contextmenu', e => {
        e.preventDefault(); e.stopPropagation();
        showContextMenu(e.clientX, e.clientY, [
          { label: t('deleteArrow'), action: () => { state.arrows.splice(ai, 1); render(); } }
        ]);
      });
    }
    svg.appendChild(path);
  });
}

function buildArrowPath(from, to) {
  return `M${from.x},${from.y} L${to.x},${to.y}`;
}

// ===== Arrow Drag Creation =====
function startArrowDrag(e, ri, ii, edge) {
  const bodyScroll = document.getElementById('gantt-body-scroll');
  const scrollRect = bodyScroll.getBoundingClientRect();
  const svg = document.getElementById('arrow-svg');

  const fromRef = { rowIndex: ri, itemIndex: ii, edge };
  const fromPos = getArrowAnchorPos(fromRef);
  if (!fromPos) return;

  // Create temporary line for visual feedback
  const tempLine = document.createElementNS('http://www.w3.org/2000/svg', 'line');
  tempLine.setAttribute('x1', fromPos.x);
  tempLine.setAttribute('y1', fromPos.y);
  tempLine.setAttribute('x2', fromPos.x);
  tempLine.setAttribute('y2', fromPos.y);
  tempLine.setAttribute('stroke', '#2196F3');
  tempLine.setAttribute('stroke-width', '2');
  tempLine.setAttribute('stroke-dasharray', '4,3');
  svg.appendChild(tempLine);

  // Show all anchors during drag
  document.querySelectorAll('.arrow-anchor').forEach(a => a.classList.add('active'));

  function onMove(ev) {
    const mx = ev.clientX - scrollRect.left + bodyScroll.scrollLeft;
    const my = ev.clientY - scrollRect.top + bodyScroll.scrollTop;
    tempLine.setAttribute('x2', mx);
    tempLine.setAttribute('y2', my);
  }

  function onUp(ev) {
    document.removeEventListener('mousemove', onMove);
    document.removeEventListener('mouseup', onUp);
    tempLine.remove();
    document.querySelectorAll('.arrow-anchor').forEach(a => a.classList.remove('active'));

    // Find drop target anchor
    const mx = ev.clientX - scrollRect.left + bodyScroll.scrollLeft;
    const my = ev.clientY - scrollRect.top + bodyScroll.scrollTop;
    const target = findAnchorAtPos(mx, my, ri, ii);
    if (target) {
      // Don't allow self-arrows
      if (target.rowIndex !== ri || target.itemIndex !== ii) {
        state.arrows.push({ from: fromRef, to: target });
        pushUndo({ type: 'addArrow', arrowIndex: state.arrows.length - 1 });
        render();
      }
    }
  }

  document.addEventListener('mousemove', onMove);
  document.addEventListener('mouseup', onUp);
}

function findAnchorAtPos(mx, my, excludeRi, excludeIi) {
  const bh = parseInt(getComputedStyle(document.documentElement).getPropertyValue('--bar-height'));
  const threshold = 15;
  let best = null, bestDist = threshold;

  visibleRows.forEach((entry, vi) => {
    const ri = entry.originalIndex;
    const rh = rowHeights[vi];
    const ry = rowYOffsets[vi];
    entry.row.items.forEach((item, ii) => {
      if (ri === excludeRi && ii === excludeIi) return;
      const laneIdx = item.lane || 0;
      const laneCenter = getLaneCenterY(entry.row, laneIdx, rh);
      if (item.type === 'task') {
        const cy = ry + laneCenter;
        const leftX = getXForDate(item.startDate, columns, colWidth);
        const rightX = getXForDateEnd(item.endDate, columns, colWidth);
        // Check left anchor
        let d = Math.hypot(mx - leftX, my - cy);
        if (d < bestDist) { bestDist = d; best = { rowIndex: ri, itemIndex: ii, edge: 'left' }; }
        // Check right anchor
        d = Math.hypot(mx - rightX, my - cy);
        if (d < bestDist) { bestDist = d; best = { rowIndex: ri, itemIndex: ii, edge: 'right' }; }
      } else if (item.type === 'milestone') {
        const cx = getXForDateCenter(item.date, columns, colWidth);
        const cy = ry + laneCenter;
        const d = Math.hypot(mx - cx, my - cy);
        if (d < bestDist) { bestDist = d; best = { rowIndex: ri, itemIndex: ii, edge: 'center' }; }
      }
    });
  });
  return best;
}

// Remove arrows referencing a specific item, and adjust indices after item deletion
function removeArrowsForItem(ri, ii) {
  state.arrows = state.arrows.filter(a => {
    return !(a.from.rowIndex === ri && a.from.itemIndex === ii) &&
           !(a.to.rowIndex === ri && a.to.itemIndex === ii);
  });
  // Shift itemIndex for items after the deleted one in the same row
  state.arrows.forEach(a => {
    if (a.from.rowIndex === ri && a.from.itemIndex > ii) a.from.itemIndex--;
    if (a.to.rowIndex === ri && a.to.itemIndex > ii) a.to.itemIndex--;
  });
}

// Remove arrows for a deleted row, shift row indices
function removeArrowsForRow(ri) {
  state.arrows = state.arrows.filter(a => a.from.rowIndex !== ri && a.to.rowIndex !== ri);
  state.arrows.forEach(a => {
    if (a.from.rowIndex > ri) a.from.rowIndex--;
    if (a.to.rowIndex > ri) a.to.rowIndex--;
  });
}

// Shift arrow row indices after row insertion
function shiftArrowsForInsert(ri) {
  state.arrows.forEach(a => {
    if (a.from.rowIndex >= ri) a.from.rowIndex++;
    if (a.to.rowIndex >= ri) a.to.rowIndex++;
  });
}

// Update arrow indices after row move
function updateArrowsForMove(from, to) {
  state.arrows.forEach(a => {
    [a.from, a.to].forEach(ref => {
      if (ref.rowIndex === from) {
        ref.rowIndex = to;
      } else if (from < to) {
        if (ref.rowIndex > from && ref.rowIndex <= to) ref.rowIndex--;
      } else {
        if (ref.rowIndex >= to && ref.rowIndex < from) ref.rowIndex++;
      }
    });
  });
}

function getThunderPointsForRender() {
  // Build a point for every lane of every visible row: use explicit point if exists, otherwise default date
  const defDate = state.thunderLine.defaultDate || fmtDate(new Date());
  const explicitMap = {};
  state.thunderLine.points.forEach((p, i) => {
    const key = p.rowIndex + '_' + (p.lane || 0);
    explicitMap[key] = { date: p.date, explicitIndex: i };
  });
  const allPoints = [];
  visibleRows.forEach((entry, vi) => {
    const ri = entry.originalIndex;
    const numLanes = entry.row.lanes || 1;
    for (let li = 0; li < numLanes; li++) {
      const key = ri + '_' + li;
      if (explicitMap[key] !== undefined) {
        allPoints.push({ rowIndex: ri, lane: li, displayIndex: vi, date: explicitMap[key].date, explicit: true, explicitIndex: explicitMap[key].explicitIndex });
      } else {
        allPoints.push({ rowIndex: ri, lane: li, displayIndex: vi, date: defDate, explicit: false, explicitIndex: -1 });
      }
    }
  });
  return allPoints;
}

function getThunderPointY(p) {
  const vi = p.displayIndex;
  const row = visibleRows[vi].row;
  const rh = rowHeights[vi];
  return rowYOffsets[vi] + getLaneCenterY(row, p.lane, rh);
}

function getThunderLaneBoundaryY(p) {
  // Bottom edge of this lane within the row
  const vi = p.displayIndex;
  const row = visibleRows[vi].row;
  const rh = rowHeights[vi];
  const numLanes = row.lanes || 1;
  const labelExtra = Math.ceil(state.fontSize * 0.8) + 4;
  let hasAbove = false, hasBelow = false;
  row.items.forEach(item => {
    if (item.type === 'task' && (item.taskLabelPosition || 'inside') === 'above') hasAbove = true;
    if (item.type === 'task' && (item.taskLabelPosition || 'inside') === 'below') hasBelow = true;
  });
  const extraTop = hasAbove ? labelExtra : 0;
  const extraBottom = hasBelow ? labelExtra : 0;
  const laneH = (rh - extraTop - extraBottom) / numLanes;
  return rowYOffsets[vi] + extraTop + laneH * (p.lane + 1);
}

function getProgressDateForLane(ri, lane) {
  if (!state.progressShading || !state.thunderLine.visible) return null;
  const p = state.thunderLine.points.find(p => p.rowIndex === ri && (p.lane || 0) === lane);
  return p ? p.date : (state.thunderLine.defaultDate || null);
}

function renderThunderLine() {
  const svg = document.getElementById('thunder-svg');
  const totalW = columns.length * colWidth;
  svg.setAttribute('width', totalW);
  svg.setAttribute('height', totalBodyHeight);
  svg.innerHTML = '';

  if (!state.thunderLine.visible || visibleRows.length === 0) return;

  const pts = getThunderPointsForRender();
  const coords = pts.map(p => ({
    x: getXForDateCenter(p.date, columns, colWidth),
    y: getThunderPointY(p),
    boundaryY: getThunderLaneBoundaryY(p),
    explicit: p.explicit,
    explicitIndex: p.explicitIndex,
    rowIndex: p.rowIndex,
    lane: p.lane,
    displayIndex: p.displayIndex
  }));

  if (coords.length > 0) {
    const defX = getXForDateCenter(state.thunderLine.defaultDate || fmtDate(new Date()), columns, colWidth);
    const pathParts = [];
    pathParts.push(`${defX},${0}`);
    for (let i = 0; i < coords.length; i++) {
      pathParts.push(`${coords[i].x},${coords[i].y}`);
      pathParts.push(`${defX},${coords[i].boundaryY}`);
    }

    const polyline = document.createElementNS('http://www.w3.org/2000/svg', 'polyline');
    polyline.setAttribute('points', pathParts.join(' '));
    polyline.setAttribute('stroke', '#d32f2f');
    polyline.setAttribute('stroke-width', '2');
    polyline.setAttribute('fill', 'none');
    svg.appendChild(polyline);
  }

  // Dots
  coords.forEach((c, i) => {
    const circle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
    circle.setAttribute('cx', c.x);
    circle.setAttribute('cy', c.y);
    circle.setAttribute('r', c.explicit ? 5 : 3);
    circle.setAttribute('fill', '#d32f2f');
    if (!c.explicit) circle.setAttribute('opacity', '0.5');
    circle.classList.add('thunder-dot');
    if (appMode === 'edit') {
      circle.addEventListener('mousedown', e => {
        if (e.button !== 0) return;
        e.preventDefault(); e.stopPropagation();
        startThunderDotDrag(e, c.rowIndex, c.lane, c.explicit, c.explicitIndex);
      });
      circle.addEventListener('contextmenu', e => {
        e.preventDefault(); e.stopPropagation();
        if (c.explicit) {
          showContextMenu(e.clientX, e.clientY, [
            { label: t('deleteProgress'), action: () => { state.thunderLine.points.splice(c.explicitIndex, 1); render(); } }
          ]);
        }
      });
    }
    svg.appendChild(circle);
  });
}

// ===== Thunder Dot Drag =====
function startThunderDotDrag(e, rowIndex, lane, isExplicit, explicitIndex) {
  const bodyScroll = document.getElementById('gantt-body-scroll');
  const scrollRect = bodyScroll.getBoundingClientRect();
  let pointIndex = explicitIndex;
  let moved = false;
  const wasNew = !isExplicit;
  const oldDate = isExplicit ? state.thunderLine.points[explicitIndex].date : null;

  // If dragging a default (non-explicit) dot, create an explicit point on first move
  function ensureExplicit() {
    if (!isExplicit && pointIndex === -1) {
      const defDate = state.thunderLine.defaultDate || fmtDate(new Date());
      state.thunderLine.points.push({ rowIndex: rowIndex, lane: lane, date: defDate });
      pointIndex = state.thunderLine.points.length - 1;
      isExplicit = true;
    }
  }

  function onMove(ev) {
    moved = true;
    ensureExplicit();
    const mx = ev.clientX - scrollRect.left + bodyScroll.scrollLeft;
    const curDate = getDateForX(mx, columns, colWidth);
    const curDateStr = fmtDate(curDate);
    state.thunderLine.points[pointIndex].date = curDateStr;
    let tooltipText = formatDateLabel(curDate);
    const row = state.rows[rowIndex];
    if (row) {
      row.items.forEach(item => {
        if (item.type !== 'task') return;
        if ((item.lane || 0) !== lane) return;
        const s = parseDate(item.startDate), e = parseDate(item.endDate);
        const totalDays = daysBetween(s, e);
        if (totalDays <= 0) return;
        const elapsed = daysBetween(s, curDate);
        if (elapsed >= 0 && elapsed <= totalDays) {
          const pct = Math.round(elapsed / totalDays * 100);
          tooltipText += ` (${pct}%)`;
        }
      });
    }
    showDragTooltip(ev, tooltipText);
    renderThunderLine();
  }

  function onUp() {
    document.removeEventListener('mousemove', onMove);
    document.removeEventListener('mouseup', onUp);
    hideDragTooltip();
    if (moved) {
      pushUndo({ type: 'moveThunderDot', pointIndex, wasNew, oldDate });
      render();
    }
  }

  document.addEventListener('mousemove', onMove);
  document.addEventListener('mouseup', onUp);
}

// ===== Inline Edit =====
function startInlineEdit(parentEl, labelEl, onCommit) {
  if (parentEl.querySelector('.inline-edit')) return;

  const currentText = labelEl.textContent;
  labelEl.style.display = 'none';

  const input = document.createElement('input');
  input.type = 'text';
  input.className = 'inline-edit';
  input.value = currentText;

  // Insert input next to the hidden label
  labelEl.parentNode.insertBefore(input, labelEl.nextSibling);
  input.focus();
  input.select();

  let committed = false;
  function commit() {
    if (committed) return;
    committed = true;
    const newText = input.value;
    input.remove();
    labelEl.style.display = '';
    onCommit(newText);
  }
  function cancel() {
    if (committed) return;
    committed = true;
    input.remove();
    labelEl.style.display = '';
    labelEl.textContent = currentText;
  }

  input.addEventListener('keydown', e => {
    e.stopPropagation();
    if (e.key === 'Enter') { e.preventDefault(); commit(); }
    if (e.key === 'Escape') { e.preventDefault(); cancel(); }
  });
  input.addEventListener('blur', () => commit());
  input.addEventListener('mousedown', e => e.stopPropagation());
}

// ===== Selection =====
function isSelected(ri, ii) {
  return selectedItems.some(s => s.rowIndex === ri && s.itemIndex === ii);
}

function clearSelection() { selectedItems = []; }

function toggleSelect(ri, ii, multi) {
  const idx = selectedItems.findIndex(s => s.rowIndex === ri && s.itemIndex === ii);
  if (multi) {
    if (idx >= 0) selectedItems.splice(idx, 1);
    else selectedItems.push({ rowIndex: ri, itemIndex: ii });
  } else {
    if (idx >= 0 && selectedItems.length === 1) { /* already solo selected */ }
    else { selectedItems = [{ rowIndex: ri, itemIndex: ii }]; }
  }
}

// ===== Drag Tooltip =====
function showDragTooltip(ev, text) {
  const tip = document.getElementById('drag-tooltip');
  tip.textContent = text;
  tip.style.left = ev.clientX + 'px';
  tip.style.top = ev.clientY + 'px';
  tip.style.display = 'block';
}

function hideDragTooltip() {
  document.getElementById('drag-tooltip').style.display = 'none';
}

function formatDateLabel(d) {
  if (typeof d === 'string') d = parseDate(d);
  return `${d.getFullYear()}/${d.getMonth()+1}/${d.getDate()}`;
}

// ===== Drag & Resize =====
let _lastItemClick = { ri: -1, ii: -1, time: 0 };

function onItemMouseDown(e, ri, ii) {
  if (e.button !== 0) return;
  e.stopPropagation();

  // Detect double-click
  const now = Date.now();
  if (_lastItemClick.ri === ri && _lastItemClick.ii === ii && now - _lastItemClick.time < 400) {
    _lastItemClick = { ri: -1, ii: -1, time: 0 };
    editItemDialog(ri, ii);
    return;
  }
  _lastItemClick = { ri, ii, time: now };

  const wasSelected = isSelected(ri, ii);
  const multi = e.ctrlKey || e.metaKey;

  if (multi) {
    // Ctrl+click: toggle this item in/out of selection
    toggleSelect(ri, ii, true);
    if (!isSelected(ri, ii)) { render(); return; }
  } else if (!wasSelected) {
    // Click on unselected item without Ctrl: select only this one
    selectedItems = [{ rowIndex: ri, itemIndex: ii }];
  }
  // If already selected without Ctrl: keep current multi-selection for drag
  render();

  const bodyScroll = document.getElementById('gantt-body-scroll');
  const scrollRect = bodyScroll.getBoundingClientRect();
  const startBodyX = e.clientX - scrollRect.left + bodyScroll.scrollLeft;

  // Record original dates
  const originals = selectedItems.map(s => {
    const item = state.rows[s.rowIndex].items[s.itemIndex];
    if (item.type === 'task') return { startDate: item.startDate, endDate: item.endDate };
    return { date: item.date };
  });

  let moved = false;

  function onMove(ev) {
    const dx = ev.clientX - e.clientX;
    if (Math.abs(dx) < 3 && !moved) return;
    moved = true;
    const curBodyX = ev.clientX - scrollRect.left + bodyScroll.scrollLeft;
    const startDate = getDateForX(startBodyX, columns, colWidth);
    const curDate = getDateForX(curBodyX, columns, colWidth);
    const dayOffset = daysBetween(startDate, curDate);

    selectedItems.forEach((s, i) => {
      const item = state.rows[s.rowIndex].items[s.itemIndex];
      const orig = originals[i];
      if (item.type === 'task') {
        item.startDate = fmtDate(addDays(parseDate(orig.startDate), dayOffset));
        item.endDate = fmtDate(addDays(parseDate(orig.endDate), dayOffset));
      } else {
        item.date = fmtDate(addDays(parseDate(orig.date), dayOffset));
      }
    });

    // Show tooltip with current date(s)
    const first = state.rows[selectedItems[0].rowIndex].items[selectedItems[0].itemIndex];
    if (first.type === 'task') {
      showDragTooltip(ev, `${formatDateLabel(first.startDate)} 〜 ${formatDateLabel(first.endDate)}`);
    } else {
      showDragTooltip(ev, formatDateLabel(first.date));
    }

    renderItems();
    renderThunderLine();
  }

  function onUp() {
    document.removeEventListener('mousemove', onMove);
    document.removeEventListener('mouseup', onUp);
    hideDragTooltip();
    if (moved) {
      pushUndo({ type: 'moveItems', items: selectedItems.map((s, i) => {
        const orig = originals[i];
        return { rowIndex: s.rowIndex, itemIndex: s.itemIndex, ...orig };
      })});
      render();
    }
  }

  document.addEventListener('mousemove', onMove);
  document.addEventListener('mouseup', onUp);
}

function startResize(e, ri, ii, side) {
  e.preventDefault(); e.stopPropagation();
  const item = state.rows[ri].items[ii];
  if (item.type !== 'task') return;

  const bodyScroll = document.getElementById('gantt-body-scroll');
  const scrollRect = bodyScroll.getBoundingClientRect();
  const origStart = item.startDate, origEnd = item.endDate;

  let resizeMoved = false;

  function onMove(ev) {
    resizeMoved = true;
    const mx = ev.clientX - scrollRect.left + bodyScroll.scrollLeft;
    if (side === 'left') {
      const curDate = getDateForX(mx, columns, colWidth);
      const ed = parseDate(origEnd);
      if (curDate <= ed) item.startDate = fmtDate(curDate);
      showDragTooltip(ev, formatDateLabel(item.startDate));
    } else {
      // Right edge: subtract 1px so getDateForX returns the cell the edge belongs to
      const curDate = getDateForX(Math.max(0, mx - 1), columns, colWidth);
      const sd = parseDate(origStart);
      if (curDate >= sd) item.endDate = fmtDate(curDate);
      showDragTooltip(ev, formatDateLabel(item.endDate));
    }
    renderItems();
  }

  function onUp() {
    document.removeEventListener('mousemove', onMove);
    document.removeEventListener('mouseup', onUp);
    hideDragTooltip();
    if (resizeMoved) {
      pushUndo({ type: 'resizeItem', rowIndex: ri, itemIndex: ii, startDate: origStart, endDate: origEnd });
    }
    render();
  }

  document.addEventListener('mousemove', onMove);
  document.addEventListener('mouseup', onUp);
}

// ===== Context Menu =====
function showContextMenu(x, y, items) {
  const menu = document.getElementById('context-menu');
  menu.innerHTML = '';
  items.forEach(it => {
    if (it.sep) {
      const s = document.createElement('div');
      s.className = 'menu-sep';
      menu.appendChild(s);
    } else {
      const d = document.createElement('div');
      d.className = 'menu-item';
      d.textContent = it.label;
      d.onclick = () => { hideContextMenu(); it.action(); };
      menu.appendChild(d);
    }
  });
  menu.style.left = x + 'px';
  menu.style.top = y + 'px';
  menu.style.display = 'block';
}

function hideContextMenu() {
  document.getElementById('context-menu').style.display = 'none';
}

document.addEventListener('click', e => {
  if (!e.target.closest('#context-menu')) hideContextMenu();
});

// Body context menu
document.addEventListener('DOMContentLoaded', () => {
  const bodyScroll = document.getElementById('gantt-body-scroll');

  bodyScroll.addEventListener('contextmenu', e => {
    if (appMode !== 'edit') return;
    e.preventDefault();
    const rect = document.getElementById('gantt-body').getBoundingClientRect();
    const x = e.clientX - rect.left;
    const y = e.clientY - rect.top;
    const vi = getVisibleRowIndexForY(y);
    if (vi < 0 || vi >= visibleRows.length) return;
    const ri = visibleRows[vi].originalIndex;
    const clickDate = getDateForX(x, columns, colWidth);
    const clickDateStr = fmtDate(clickDate);

    const clickedRow = state.rows[ri];
    const clickedRh = rowHeights[vi];
    const yInRow = y - rowYOffsets[vi];
    const clickedLane = getLaneForY(clickedRow, yInRow, clickedRh);

    const menuItems = [
      { label: `${t('addTask')} (${clickDateStr})`, action: () => addTaskDialog(ri, clickDateStr, clickedLane) },
      { label: `${t('addMilestone')} (${clickDateStr})`, action: () => addMilestoneDialog(ri, clickDateStr, clickedLane) },
      { sep: true },
      { label: t('addLane'), action: () => { addLane(ri); } },
    ];
    if ((clickedRow.lanes || 1) >= 2) {
      menuItems.push({ label: t('removeLane'), action: () => { removeLane(ri); } });
    }
    menuItems.push({ sep: true });
    menuItems.push({ label: t('addProgress'), action: () => { addThunderPoint(ri, clickedLane, clickDateStr); } });

    if (selectedItems.length > 0) {
      menuItems.push({ sep: true });
      menuItems.push({ label: t('deleteSelected'), action: () => deleteSelected() });
    }

    showContextMenu(e.clientX, e.clientY, menuItems);
  });

  bodyScroll.addEventListener('mousedown', e => {
    if (e.button === 0 && !e.target.closest('.gantt-item') && !e.target.closest('.thunder-dot')) {
      clearSelection();
      render();
    }
  });

  // Sync scroll
  const headerScroll = document.getElementById('gantt-header-scroll');
  bodyScroll.addEventListener('scroll', () => {
    headerScroll.scrollLeft = bodyScroll.scrollLeft;
    document.getElementById('gantt-sidebar-scroll').scrollTop = bodyScroll.scrollTop;
  });
  // Also sync if header is scrolled directly (e.g. trackpad)
  headerScroll.addEventListener('scroll', () => {
    bodyScroll.scrollLeft = headerScroll.scrollLeft;
  });
});

// ===== Thunder Line =====
function addThunderPoint(ri, lane, dateStr) {
  const existing = state.thunderLine.points.findIndex(p => p.rowIndex === ri && (p.lane || 0) === lane);
  if (existing >= 0) {
    state.thunderLine.points[existing].date = dateStr;
  } else {
    state.thunderLine.points.push({ rowIndex: ri, lane: lane, date: dateStr });
  }
  render();
}

function toggleArrows(visible) {
  state.arrowsVisible = visible;
  render();
}

function toggleThunder(visible) {
  state.thunderLine.visible = visible;
  render();
}

function toggleProgressShading(enabled) {
  state.progressShading = enabled;
  render();
}

function changeThunderDefault(dateStr) {
  state.thunderLine.defaultDate = dateStr;
  render();
}

function resetProgressPoints() {
  state.thunderLine.points = [];
  render();
}

// ===== Dialogs =====
function showModal(title, fields, onOk) {
  const overlay = document.createElement('div');
  overlay.className = 'modal-overlay';
  const modal = document.createElement('div');
  modal.className = 'modal';
  const h3 = document.createElement('h3');
  h3.textContent = title;
  modal.appendChild(h3);

  const inputs = {};
  fields.forEach(f => {
    const div = document.createElement('div');
    div.className = 'field';
    const label = document.createElement('label');
    label.textContent = f.label;
    div.appendChild(label);

    if (f.type === 'color') {
      const container = document.createElement('div');
      container.className = 'color-options';
      let selected = f.value || COLORS[0];
      COLORS.forEach(c => {
        const opt = document.createElement('div');
        opt.className = 'color-opt' + (c === selected ? ' selected' : '');
        opt.style.background = c;
        opt.onclick = () => {
          container.querySelectorAll('.color-opt').forEach(o => o.classList.remove('selected'));
          opt.classList.add('selected');
          selected = c;
          inputs[f.key] = { value: c };
        };
        container.appendChild(opt);
      });
      inputs[f.key] = { value: selected };
      div.appendChild(container);
    } else if (f.type === 'rowColor') {
      const container = document.createElement('div');
      container.className = 'color-options';
      let selected = f.value || null;
      ROW_COLORS.forEach(c => {
        const opt = document.createElement('div');
        opt.className = 'color-opt' + (c === selected ? ' selected' : '');
        if (c === null) {
          opt.style.background = '#fff';
          opt.style.position = 'relative';
          opt.style.overflow = 'hidden';
          const line = document.createElement('div');
          line.style.cssText = 'position:absolute;top:0;left:50%;width:2px;height:141%;background:#d00;transform:rotate(45deg);transform-origin:top center;';
          opt.appendChild(line);
        } else {
          opt.style.background = c;
        }
        opt.onclick = () => {
          container.querySelectorAll('.color-opt').forEach(o => o.classList.remove('selected'));
          opt.classList.add('selected');
          selected = c;
          inputs[f.key] = { value: c };
        };
        container.appendChild(opt);
      });
      inputs[f.key] = { value: selected };
      div.appendChild(container);
    } else if (f.type === 'select') {
      const sel = document.createElement('select');
      f.options.forEach(o => {
        const opt = document.createElement('option');
        opt.value = o.value; opt.textContent = o.label;
        if (o.value === f.value) opt.selected = true;
        sel.appendChild(opt);
      });
      inputs[f.key] = sel;
      div.appendChild(sel);
    } else if (f.type === 'textarea') {
      const ta = document.createElement('textarea');
      ta.rows = 3;
      ta.value = f.value || '';
      ta.style.width = '100%';
      ta.style.resize = 'vertical';
      inputs[f.key] = ta;
      div.appendChild(ta);
    } else {
      const inp = document.createElement('input');
      inp.type = f.type || 'text';
      inp.value = f.value || '';
      inputs[f.key] = inp;
      div.appendChild(inp);
    }
    modal.appendChild(div);
  });

  const btns = document.createElement('div');
  btns.className = 'modal-btns';
  const btnCancel = document.createElement('button');
  btnCancel.textContent = t('cancel');
  btnCancel.onclick = () => overlay.remove();
  const btnOk = document.createElement('button');
  btnOk.className = 'btn-primary';
  btnOk.textContent = 'OK';
  btnOk.onclick = () => {
    const vals = {};
    for (const k in inputs) vals[k] = inputs[k].value;
    onOk(vals);
    overlay.remove();
  };
  btns.appendChild(btnCancel);
  btns.appendChild(btnOk);
  modal.appendChild(btns);

  overlay.appendChild(modal);
  overlay.addEventListener('mousedown', e => { if(e.target === overlay) overlay.remove(); });
  document.body.appendChild(overlay);

  // Focus first input
  const firstInput = modal.querySelector('input[type="text"], input[type="date"]');
  if (firstInput) setTimeout(() => firstInput.focus(), 50);
}

function getTaskLabelPosOptions() {
  return [
    { value: 'inside', label: t('posInside') },
    { value: 'above', label: t('posAbove') },
    { value: 'below', label: t('posBelow') },
    { value: 'left', label: t('posLeft') },
    { value: 'right', label: t('posRight') }
  ];
}

function getLaneOptions(numLanes) {
  const opts = [];
  for (let i = 0; i < numLanes; i++) {
    opts.push({ value: String(i), label: `${t('lane')} ${i + 1}` });
  }
  return opts;
}

function editRowDialog(ri) {
  const row = state.rows[ri];
  showModal(t('editRow'), [
    { key: 'color', label: t('rowColor'), type: 'rowColor', value: row.color || null },
    { key: 'memo', label: t('rowMemo'), type: 'textarea', value: row.memo || '' },
  ], vals => {
    row.color = vals.color || null;
    row.memo = vals.memo;
    render();
  });
}

function addTaskDialog(ri, dateStr, clickedLane) {
  const endDate = fmtDate(addDays(parseDate(dateStr), 30));
  const numLanes = state.rows[ri].lanes || 1;
  const fields = [
    { key: 'label', label: t('label'), type: 'text', value: '' },
    { key: 'startDate', label: t('startDate'), type: 'date', value: dateStr },
    { key: 'endDate', label: t('endDate'), type: 'date', value: endDate },
    { key: 'color', label: t('color'), type: 'color', value: COLORS[0] },
    { key: 'taskLabelPosition', label: t('labelPos'), type: 'select', value: 'inside', options: getTaskLabelPosOptions() },
    { key: 'memo', label: t('memo'), type: 'textarea', value: '' }
  ];
  if (numLanes > 1) {
    fields.splice(1, 0, { key: 'lane', label: t('lane'), type: 'select', value: String(clickedLane || 0), options: getLaneOptions(numLanes) });
  }
  showModal(t('addTask'), fields, vals => {
    if (!vals.startDate || !vals.endDate) return;
    state.rows[ri].items.push({
      type: 'task', startDate: vals.startDate, endDate: vals.endDate,
      label: vals.label, color: vals.color, taskLabelPosition: vals.taskLabelPosition,
      memo: vals.memo,
      lane: numLanes > 1 ? parseInt(vals.lane) : 0
    });
    render();
  });
}

function addMilestoneDialog(ri, dateStr, clickedLane) {
  const numLanes = state.rows[ri].lanes || 1;
  const fields = [
    { key: 'label', label: t('label'), type: 'text', value: '' },
    { key: 'date', label: t('date'), type: 'date', value: dateStr },
    { key: 'labelPosition', label: t('labelPos'), type: 'select', value: 'after',
      options: [{ value: 'before', label: t('posBefore') }, { value: 'after', label: t('posAfter') }] },
    { key: 'milestoneShape', label: t('milestoneShape'), type: 'select', value: '▽',
      options: [{ value: '▽', label: '▽' }, { value: '▼', label: '▼' }, { value: '△', label: '△' }, { value: '▲', label: '▲' }] },
    { key: 'milestoneColor', label: t('milestoneColor'), type: 'color', value: '#d32f2f' },
    { key: 'memo', label: t('memo'), type: 'textarea', value: '' }
  ];
  if (numLanes > 1) {
    fields.splice(1, 0, { key: 'lane', label: t('lane'), type: 'select', value: String(clickedLane || 0), options: getLaneOptions(numLanes) });
  }
  showModal(t('addMilestone'), fields, vals => {
    if (!vals.date) return;
    state.rows[ri].items.push({
      type: 'milestone', date: vals.date,
      label: vals.label, labelPosition: vals.labelPosition,
      milestoneShape: vals.milestoneShape, milestoneColor: vals.milestoneColor,
      memo: vals.memo,
      lane: numLanes > 1 ? parseInt(vals.lane) : 0
    });
    render();
  });
}

function editItemDialog(ri, ii) {
  const item = state.rows[ri].items[ii];
  const numLanes = state.rows[ri].lanes || 1;
  if (item.type === 'task') {
    const fields = [
      { key: 'label', label: t('label'), type: 'text', value: item.label },
      { key: 'startDate', label: t('startDate'), type: 'date', value: item.startDate },
      { key: 'endDate', label: t('endDate'), type: 'date', value: item.endDate },
      { key: 'color', label: t('color'), type: 'color', value: item.color || COLORS[0] },
      { key: 'taskLabelPosition', label: t('labelPos'), type: 'select', value: item.taskLabelPosition || 'inside', options: getTaskLabelPosOptions() },
      { key: 'memo', label: t('memo'), type: 'textarea', value: item.memo || '' }
    ];
    if (numLanes > 1) {
      fields.splice(1, 0, { key: 'lane', label: t('lane'), type: 'select', value: String(item.lane || 0), options: getLaneOptions(numLanes) });
    }
    showModal(t('editTask'), fields, vals => {
      if (!vals.startDate || !vals.endDate) return;
      item.label = vals.label;
      item.startDate = vals.startDate;
      item.endDate = vals.endDate;
      item.color = vals.color;
      item.taskLabelPosition = vals.taskLabelPosition;
      item.memo = vals.memo;
      if (numLanes > 1) item.lane = parseInt(vals.lane);
      render();
    });
  } else {
    const fields = [
      { key: 'label', label: t('label'), type: 'text', value: item.label },
      { key: 'date', label: t('date'), type: 'date', value: item.date },
      { key: 'labelPosition', label: t('labelPos'), type: 'select', value: item.labelPosition || 'after',
        options: [{ value: 'before', label: t('posBefore') }, { value: 'after', label: t('posAfter') }] },
      { key: 'milestoneShape', label: t('milestoneShape'), type: 'select', value: item.milestoneShape || '▽',
        options: [{ value: '▽', label: '▽' }, { value: '▼', label: '▼' }, { value: '△', label: '△' }, { value: '▲', label: '▲' }] },
      { key: 'milestoneColor', label: t('milestoneColor'), type: 'color', value: item.milestoneColor || '#d32f2f' },
      { key: 'memo', label: t('memo'), type: 'textarea', value: item.memo || '' }
    ];
    if (numLanes > 1) {
      fields.splice(1, 0, { key: 'lane', label: t('lane'), type: 'select', value: String(item.lane || 0), options: getLaneOptions(numLanes) });
    }
    showModal(t('editMilestone'), fields, vals => {
      if (!vals.date) return;
      item.label = vals.label;
      item.date = vals.date;
      item.labelPosition = vals.labelPosition;
      item.milestoneShape = vals.milestoneShape;
      item.milestoneColor = vals.milestoneColor;
      item.memo = vals.memo;
      if (numLanes > 1) item.lane = parseInt(vals.lane);
      render();
    });
  }
}

function deleteSelected() {
  // Delete in reverse order to maintain indices
  const sorted = [...selectedItems].sort((a, b) => b.rowIndex - a.rowIndex || b.itemIndex - a.itemIndex);
  sorted.forEach(s => {
    removeArrowsForItem(s.rowIndex, s.itemIndex);
    state.rows[s.rowIndex].items.splice(s.itemIndex, 1);
  });
  selectedItems = [];
  render();
}

// ===== Mode =====
function setMode(mode) {
  appMode = mode;
  document.getElementById('btn-edit-mode').classList.toggle('active', mode === 'edit');
  document.getElementById('btn-view-mode').classList.toggle('active', mode === 'view');
  document.getElementById('edit-controls').style.display = mode === 'edit' ? '' : 'none';
  document.getElementById('view-controls').style.display = mode === 'view' ? '' : 'none';
  document.body.classList.toggle('edit-mode', mode === 'edit');
  document.body.classList.toggle('view-mode', mode === 'view');

  if (mode === 'view') {
    clearSelection();
  }
  render();
}

// ===== Time Unit =====
function changeUnit(unit) {
  state.timeUnit = unit;
  customColWidth = null;
  render();
}

// ===== Font Size =====
function changeFontSize(delta) {
  state.fontSize = Math.max(8, Math.min(24, state.fontSize + delta));
  document.documentElement.style.setProperty('--font-size', state.fontSize + 'px');
  render();
}

// ===== Column Add/Remove =====
function addColumnStart() {
  const sd = parseDate(state.startDate);
  if (state.timeUnit === 'month') {
    state.startDate = fmtDate(new Date(sd.getFullYear(), sd.getMonth() - 1, 1));
  } else if (state.timeUnit === 'week') {
    state.startDate = fmtDate(addDays(sd, -7));
  } else {
    state.startDate = fmtDate(addDays(sd, -1));
  }
  render();
}

function addColumnEnd() {
  const ed = parseDate(state.endDate);
  if (state.timeUnit === 'month') {
    const next = new Date(ed.getFullYear(), ed.getMonth() + 1, 1);
    state.endDate = fmtDate(monthEnd(next));
  } else if (state.timeUnit === 'week') {
    state.endDate = fmtDate(addDays(ed, 7));
  } else {
    state.endDate = fmtDate(addDays(ed, 1));
  }
  render();
}

function removeColumnStart() {
  const sd = parseDate(state.startDate);
  let newStart;
  if (state.timeUnit === 'month') {
    newStart = new Date(sd.getFullYear(), sd.getMonth() + 1, 1);
  } else if (state.timeUnit === 'week') {
    newStart = addDays(sd, 7);
  } else {
    newStart = addDays(sd, 1);
  }
  if (newStart < parseDate(state.endDate)) {
    state.startDate = fmtDate(newStart);
    render();
  }
}

function removeColumnEnd() {
  const ed = parseDate(state.endDate);
  let newEnd;
  if (state.timeUnit === 'month') {
    newEnd = new Date(ed.getFullYear(), ed.getMonth(), 0);
  } else if (state.timeUnit === 'week') {
    newEnd = addDays(ed, -7);
  } else {
    newEnd = addDays(ed, -1);
  }
  if (newEnd > parseDate(state.startDate)) {
    state.endDate = fmtDate(newEnd);
    render();
  }
}

// ===== Row =====
function addRow() {
  state.rows.push({ name: t('newTask'), items: [], lanes: 1 });
  render();
}

function insertRowAt(ri) {
  state.rows.splice(ri, 0, { name: t('newTask'), items: [], lanes: 1 });
  // Shift thunder line points at or after the inserted position
  state.thunderLine.points.forEach(p => {
    if (p.rowIndex >= ri) p.rowIndex++;
  });
  shiftArrowsForInsert(ri);
  // Shift selected items
  selectedItems = selectedItems.map(s => ({
    rowIndex: s.rowIndex >= ri ? s.rowIndex + 1 : s.rowIndex,
    itemIndex: s.itemIndex
  }));
  render();
}

function deleteRowAt(ri) {
  state.rows.splice(ri, 1);
  // Remove thunder line points for the deleted row and shift others
  state.thunderLine.points = state.thunderLine.points.filter(p => p.rowIndex !== ri);
  state.thunderLine.points.forEach(p => {
    if (p.rowIndex > ri) p.rowIndex--;
  });
  removeArrowsForRow(ri);
  selectedItems = [];
  render();
}

// ===== Lane Management =====
function addLane(ri) {
  if (!state.rows[ri].lanes) state.rows[ri].lanes = 1;
  state.rows[ri].lanes++;
  render();
}

function removeLane(ri) {
  const row = state.rows[ri];
  if (!row.lanes || row.lanes <= 1) return;
  const newLanes = row.lanes - 1;
  // Clamp item lanes to fit within new lane count
  row.items.forEach(item => {
    if ((item.lane || 0) >= newLanes) {
      item.lane = newLanes - 1;
    }
  });
  // Remove thunder points for the removed lane and clamp others
  state.thunderLine.points = state.thunderLine.points.filter(p => {
    if (p.rowIndex === ri && (p.lane || 0) >= newLanes) return false;
    return true;
  });
  row.lanes = newLanes;
  render();
}

// ===== View Range =====
function applyViewRange() {
  const vs = document.getElementById('view-start').value;
  const ve = document.getElementById('view-end').value;
  if (vs && ve && vs <= ve) {
    viewRange = { start: vs, end: ve };
    render();
  }
}

function clearViewRange() {
  viewRange = null;
  document.getElementById('view-start').value = state.startDate;
  document.getElementById('view-end').value = state.endDate;
  render();
}

// ===== Export / Import =====
function exportJSON() {
  state.sidebarWidth = parseInt(getComputedStyle(document.documentElement).getPropertyValue('--sidebar-width'));
  state.colWidth = customColWidth;
  state.bodyHeight = customBodyHeight;
  state.viewRange = viewRange;
  const json = JSON.stringify(state, null, 2);
  const blob = new Blob([json], { type: 'application/json' });
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url;
  const now = new Date();
  const ts = now.getFullYear()
    + String(now.getMonth()+1).padStart(2,'0')
    + String(now.getDate()).padStart(2,'0')
    + '-'
    + String(now.getHours()).padStart(2,'0')
    + String(now.getMinutes()).padStart(2,'0')
    + String(now.getSeconds()).padStart(2,'0');
  a.download = 'gantt-chart-' + ts + '.json';
  a.click();
  URL.revokeObjectURL(url);
  showToast(t('exported'));
}

function importJSON() {
  document.getElementById('file-input').click();
}

function applyJSONData(data) {
  if (!(data.rows && data.startDate && data.endDate)) return false;
  state = data;
  if (state.rows) {
    state.rows.forEach(row => {
      if (row.lanes === undefined) row.lanes = 1;
      if (row.color === undefined) row.color = null;
      if (row.memo === undefined) row.memo = '';
      if (row.collapsed === undefined) row.collapsed = false;
      row.items.forEach(item => {
        if (item.lane === undefined) item.lane = 0;
      });
    });
  }
  if (!state.thunderLine) state.thunderLine = { visible: true, points: [], defaultDate: fmtDate(new Date()) };
  if (!state.arrows) state.arrows = [];
  if (state.arrowsVisible === undefined) state.arrowsVisible = true;
  state.thunderLine.defaultDate = fmtDate(new Date()); // always reset to today on load
  if (state.thunderLine.points) {
    state.thunderLine.points.forEach(p => {
      if (p.lane === undefined) p.lane = 0;
    });
  }
  if (!state.fontSize) state.fontSize = 14;
  if (state.cornerLabel === undefined) state.cornerLabel = '';
  if (state.progressShading === undefined) state.progressShading = false;
  if (state.lang) { currentLang = state.lang; } else { state.lang = currentLang; }
  document.getElementById('sel-lang').value = currentLang;
  updateUIText();
  document.getElementById('sel-unit').value = state.timeUnit || 'month';
  document.getElementById('chk-arrows').checked = state.arrowsVisible !== false;
  document.getElementById('chk-thunder').checked = state.thunderLine.visible;
  document.getElementById('chk-progress-shading').checked = state.progressShading;
  document.getElementById('thunder-default-date').value = state.thunderLine.defaultDate;
  if (state.sidebarWidth) {
    document.documentElement.style.setProperty('--sidebar-width', state.sidebarWidth + 'px');
  }
  customColWidth = state.colWidth || null;
  customBodyHeight = state.bodyHeight || null;
  viewRange = state.viewRange || null;
  if (viewRange) {
    document.getElementById('view-start').value = viewRange.start;
    document.getElementById('view-end').value = viewRange.end;
  } else {
    document.getElementById('view-start').value = state.startDate;
    document.getElementById('view-end').value = state.endDate;
  }
  selectedItems = [];
  render();
  return true;
}

function loadJSONFile(file) {
  const reader = new FileReader();
  reader.onload = e => {
    try {
      const data = JSON.parse(e.target.result);
      if (applyJSONData(data)) {
        showToast(t('imported'));
      } else {
        alert(t('invalidFile'));
      }
    } catch (err) {
      alert(t('jsonError') + err.message);
    }
  };
  reader.readAsText(file);
}

function handleFileImport(event) {
  const file = event.target.files[0];
  if (!file) return;
  loadJSONFile(file);
  event.target.value = '';
}

// ===== Image Copy =====
async function copyAsImage() {
  const canvas = renderToCanvas();
  try {
    const blob = await new Promise(resolve => canvas.toBlob(resolve, 'image/png'));
    await navigator.clipboard.write([new ClipboardItem({ 'image/png': blob })]);
    showToast(t('imageCopied'));
  } catch (err) {
    // Fallback: download
    canvas.toBlob(blob => {
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url; a.download = 'gantt_chart.png'; a.click();
      URL.revokeObjectURL(url);
      showToast(t('imageDownloaded'));
    });
  }
}

function renderToCanvas() {
  const bh = parseInt(getComputedStyle(document.documentElement).getPropertyValue('--bar-height'));
  const sw = parseInt(getComputedStyle(document.documentElement).getPropertyValue('--sidebar-width'));
  const hh = parseInt(getComputedStyle(document.documentElement).getPropertyValue('--header-height'));
  const fs = state.fontSize;

  computeRowLayout();

  const totalW = columns.length * colWidth + sw;
  const totalH = totalBodyHeight + hh;

  const dpr = window.devicePixelRatio || 1;
  const canvas = document.createElement('canvas');
  canvas.width = totalW * dpr;
  canvas.height = totalH * dpr;
  const ctx = canvas.getContext('2d');
  ctx.scale(dpr, dpr);

  // ===== Pass 1: Backgrounds =====
  ctx.fillStyle = '#fff';
  ctx.fillRect(0, 0, totalW, totalH);

  // Header background
  ctx.fillStyle = '#f0f4f8';
  ctx.fillRect(0, 0, totalW, hh);

  // Weekend column backgrounds
  columns.forEach((col, i) => {
    if (col.weekend) {
      const x = sw + i * colWidth;
      ctx.fillStyle = '#fff3e0';
      ctx.fillRect(x, 0, colWidth, totalH);
    }
  });

  // Row backgrounds
  visibleRows.forEach((entry, vi) => {
    const rh = rowHeights[vi];
    const y = hh + rowYOffsets[vi];
    if (entry.row.color) {
      ctx.fillStyle = entry.row.color;
      ctx.fillRect(0, y, totalW, rh);
    } else {
      ctx.fillStyle = vi % 2 === 0 ? '#fafbfc' : '#fff';
      ctx.fillRect(0, y, sw, rh);
    }
  });

  // ===== Pass 2: Grid lines =====
  // Column vertical lines (body)
  ctx.strokeStyle = '#e8e8e8';
  ctx.lineWidth = 1;
  columns.forEach((col, i) => {
    const x = sw + i * colWidth;
    ctx.beginPath(); ctx.moveTo(x + colWidth, hh); ctx.lineTo(x + colWidth, totalH); ctx.stroke();
  });

  // Column vertical lines (header)
  ctx.strokeStyle = '#d0d0d0';
  ctx.lineWidth = 1;
  columns.forEach((col, i) => {
    const x = sw + i * colWidth;
    ctx.beginPath(); ctx.moveTo(x + colWidth, 0); ctx.lineTo(x + colWidth, hh); ctx.stroke();
  });

  // Year-start vertical lines (thicker)
  let prevYear = null;
  columns.forEach((col, i) => {
    const x = sw + i * colWidth;
    if (col.year !== prevYear && i > 0) {
      ctx.strokeStyle = '#bbb';
      ctx.lineWidth = 2;
      ctx.beginPath(); ctx.moveTo(x, 0); ctx.lineTo(x, totalH); ctx.stroke();
    }
    prevYear = col.year;
  });

  // Row horizontal lines
  ctx.strokeStyle = '#d0d0d0';
  ctx.lineWidth = 1;
  visibleRows.forEach((entry, vi) => {
    const rh = rowHeights[vi];
    const y = hh + rowYOffsets[vi];
    ctx.beginPath(); ctx.moveTo(0, y + rh); ctx.lineTo(totalW, y + rh); ctx.stroke();
  });

  // Header bottom line & Sidebar border
  ctx.strokeStyle = '#bbb';
  ctx.lineWidth = 2;
  ctx.beginPath(); ctx.moveTo(0, hh); ctx.lineTo(totalW, hh); ctx.stroke();
  ctx.beginPath(); ctx.moveTo(sw, 0); ctx.lineTo(sw, totalH); ctx.stroke();

  // ===== Pass 3: Text & Items =====
  // Corner label
  ctx.fillStyle = '#666';
  ctx.font = `bold ${fs * 0.85}px sans-serif`;
  ctx.textBaseline = 'middle';
  ctx.fillText(state.cornerLabel || t('taskName'), 8, hh / 2);

  // Header labels
  ctx.font = `600 ${fs * 0.85}px sans-serif`;
  prevYear = null;
  columns.forEach((col, i) => {
    const x = sw + i * colWidth;
    let lbl = col.label;
    if (col.year !== prevYear) {
      if (state.timeUnit === 'month') lbl = col.year + '/' + lbl;
      prevYear = col.year;
    }
    ctx.fillStyle = '#555';
    ctx.fillText(lbl, x + 4, hh / 2 + 4);
  });

  // Rows: names & items
  visibleRows.forEach((entry, vi) => {
    const row = entry.row;
    const rh = rowHeights[vi];
    const y = hh + rowYOffsets[vi];

    // Row name (with wrapping and explicit line breaks)
    ctx.fillStyle = '#333';
    ctx.font = `${fs}px sans-serif`;
    ctx.textBaseline = 'top';
    const maxTextW = sw - 16;
    const lineH = fs * 1.3;
    let lines = [];
    const paragraphs = row.name.split('\n');
    paragraphs.forEach(para => {
      let curLine = '';
      for (const ch of para) {
        const testLine = curLine + ch;
        if (ctx.measureText(testLine).width > maxTextW && curLine) {
          lines.push(curLine);
          curLine = ch;
        } else {
          curLine = testLine;
        }
      }
      lines.push(curLine);
    });
    const totalTextH = lines.length * lineH;
    const textStartY = y + (rh - totalTextH) / 2;
    lines.forEach((line, li) => {
      ctx.fillText(line, 8, textStartY + li * lineH);
    });

    // Lane separator lines
    const numLanes = row.lanes || 1;
    if (numLanes > 1) {
      const canvasLabelExtra = Math.ceil(fs * 0.8) + 4;
      let cHasAbove = false, cHasBelow = false;
      row.items.forEach(item => {
        if (item.type === 'task') {
          const pos = item.taskLabelPosition || 'inside';
          if (pos === 'above') cHasAbove = true;
          if (pos === 'below') cHasBelow = true;
        }
      });
      const cExtraTop = cHasAbove ? canvasLabelExtra : 0;
      const cExtraBottom = cHasBelow ? canvasLabelExtra : 0;
      const cLaneH = (rh - cExtraTop - cExtraBottom) / numLanes;
      ctx.strokeStyle = '#ccc';
      ctx.lineWidth = 1;
      ctx.setLineDash([4, 3]);
      for (let li = 1; li < numLanes; li++) {
        const sepY = y + cExtraTop + cLaneH * li;
        ctx.beginPath(); ctx.moveTo(sw, sepY); ctx.lineTo(totalW, sepY); ctx.stroke();
      }
      ctx.setLineDash([]);
    }

    // Items
    row.items.forEach(item => {
      if (item.type === 'task') {
        const x1 = sw + getXForDate(item.startDate, columns, colWidth);
        const x2 = sw + getXForDateEnd(item.endDate, columns, colWidth);
        const w = Math.max(x2 - x1, 4);
        const laneIdx = item.lane || 0;
        const laneCenter = getLaneCenterY(row, laneIdx, rh);
        const barY = y + laneCenter - bh / 2;

        ctx.fillStyle = item.color || COLORS[0];
        roundRect(ctx, x1, barY, w, bh, 4);
        ctx.fill();

        // Shadow
        ctx.shadowColor = 'rgba(0,0,0,.15)';
        ctx.shadowBlur = 3;
        ctx.shadowOffsetY = 1;
        roundRect(ctx, x1, barY, w, bh, 4);
        ctx.fill();
        ctx.shadowColor = 'transparent';
        ctx.shadowBlur = 0;
        ctx.shadowOffsetY = 0;

        // Progress shading
        const cProgressDate = getProgressDateForLane(entry.originalIndex, laneIdx);
        if (cProgressDate) {
          const cTaskStart = parseDate(item.startDate), cTaskEnd = parseDate(item.endDate);
          const cProgD = parseDate(cProgressDate);
          const cTotalDays = daysBetween(cTaskStart, cTaskEnd);
          if (cTotalDays > 0) {
            const cElapsed = daysBetween(cTaskStart, cProgD);
            const cPct = Math.max(0, Math.min(1, cElapsed / cTotalDays));
            if (cPct > 0) {
              const shadingW = w * cPct;
              ctx.save();
              roundRect(ctx, x1, barY, w, bh, 4);
              ctx.clip();
              ctx.fillStyle = 'rgba(0,0,0,0.15)';
              ctx.fillRect(x1, barY, shadingW, bh);
              ctx.restore();
            }
          }
        }

        if (item.label) {
          const tlp = item.taskLabelPosition || 'inside';
          ctx.font = `${fs * 0.8}px sans-serif`;
          ctx.textBaseline = 'middle';
          const tw = ctx.measureText(item.label).width;
          if (tlp === 'inside') {
            ctx.fillStyle = '#fff';
            if (tw < w - 8) {
              ctx.fillText(item.label, x1 + (w - tw) / 2, barY + bh / 2);
            }
          } else {
            ctx.fillStyle = '#333';
            if (tlp === 'above') {
              ctx.textBaseline = 'alphabetic';
              ctx.fillText(item.label, x1, barY - 4);
              ctx.textBaseline = 'middle';
            } else if (tlp === 'below') {
              ctx.textBaseline = 'top';
              ctx.fillText(item.label, x1, barY + bh + 4);
              ctx.textBaseline = 'middle';
            } else if (tlp === 'left') {
              ctx.fillText(item.label, x1 - tw - 4, barY + bh / 2);
            } else if (tlp === 'right') {
              ctx.fillText(item.label, x1 + w + 4, barY + bh / 2);
            }
          }
        }
      } else if (item.type === 'milestone') {
        const x = sw + getXForDateCenter(item.date, columns, colWidth);
        const msLaneIdx = item.lane || 0;
        const msLaneCenter = getLaneCenterY(row, msLaneIdx, rh);
        const my = y + msLaneCenter;
        ctx.fillStyle = item.milestoneColor || '#d32f2f';
        ctx.font = `${fs * 1.3}px sans-serif`;
        ctx.textBaseline = 'middle';
        const msChar = item.milestoneShape || '▽';
        const markW = ctx.measureText(msChar).width;
        ctx.fillText(msChar, x - markW / 2, my);

        if (item.label) {
          ctx.fillStyle = '#333';
          ctx.font = `${fs * 0.8}px sans-serif`;
          if (item.labelPosition === 'before') {
            const lw = ctx.measureText(item.label).width;
            ctx.fillText(item.label, x - markW / 2 - lw - 4, my);
          } else {
            ctx.fillText(item.label, x + markW / 2 + 4, my);
          }
        }
      }
    });
  });

  // Arrows
  if (state.arrowsVisible !== false && state.arrows && state.arrows.length > 0) {
    state.arrows.forEach(arrow => {
      const fromPos = getArrowAnchorPos(arrow.from);
      const toPos = getArrowAnchorPos(arrow.to);
      if (!fromPos || !toPos) return;
      const fp = { x: sw + fromPos.x, y: hh + fromPos.y };
      const tp = { x: sw + toPos.x, y: hh + toPos.y };

      // Draw straight arrow line
      ctx.strokeStyle = '#666';
      ctx.lineWidth = 1.5;
      ctx.beginPath();
      ctx.moveTo(fp.x, fp.y);
      ctx.lineTo(tp.x, tp.y);
      ctx.stroke();

      // Draw arrowhead
      const angle = Math.atan2(tp.y - fp.y, tp.x - fp.x);
      const headLen = 8;
      ctx.fillStyle = '#666';
      ctx.beginPath();
      ctx.moveTo(tp.x, tp.y);
      ctx.lineTo(tp.x - headLen * Math.cos(angle - Math.PI/6), tp.y - headLen * Math.sin(angle - Math.PI/6));
      ctx.lineTo(tp.x - headLen * Math.cos(angle + Math.PI/6), tp.y - headLen * Math.sin(angle + Math.PI/6));
      ctx.closePath();
      ctx.fill();
    });
  }

  // Thunder line
  if (state.thunderLine.visible && visibleRows.length > 0) {
    const pts = getThunderPointsForRender();
    const coords = pts.map(p => ({
      x: sw + getXForDateCenter(p.date, columns, colWidth),
      y: hh + getThunderPointY(p),
      boundaryY: hh + getThunderLaneBoundaryY(p),
      explicit: p.explicit,
      displayIndex: p.displayIndex
    }));

    if (coords.length > 0) {
      const defX = sw + getXForDateCenter(state.thunderLine.defaultDate || fmtDate(new Date()), columns, colWidth);
      ctx.strokeStyle = '#d32f2f';
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.moveTo(defX, hh);
      for (let i = 0; i < coords.length; i++) {
        ctx.lineTo(coords[i].x, coords[i].y);
        ctx.lineTo(defX, coords[i].boundaryY);
      }
      ctx.stroke();
    }

    coords.forEach(c => {
      ctx.beginPath();
      ctx.arc(c.x, c.y, c.explicit ? 5 : 3, 0, Math.PI * 2);
      ctx.fillStyle = '#d32f2f';
      ctx.globalAlpha = c.explicit ? 1 : 0.5;
      ctx.fill();
      ctx.globalAlpha = 1;
    });
  }

  return canvas;
}

function roundRect(ctx, x, y, w, h, r) {
  ctx.beginPath();
  ctx.moveTo(x + r, y);
  ctx.lineTo(x + w - r, y);
  ctx.quadraticCurveTo(x + w, y, x + w, y + r);
  ctx.lineTo(x + w, y + h - r);
  ctx.quadraticCurveTo(x + w, y + h, x + w - r, y + h);
  ctx.lineTo(x + r, y + h);
  ctx.quadraticCurveTo(x, y + h, x, y + h - r);
  ctx.lineTo(x, y + r);
  ctx.quadraticCurveTo(x, y, x + r, y);
  ctx.closePath();
}

// ===== Toast =====

function showToast(msg) {
  const toast = document.getElementById('toast');
  toast.textContent = msg;
  toast.style.display = 'block';
  setTimeout(() => { toast.style.display = 'none'; }, 2000);
}

// ===== Resize Handle (drag right edge of last column to change column width) =====
function initResizeHandle() {
  const handle = document.getElementById('gantt-resize-handle');

  handle.addEventListener('mousedown', e => {
    if (e.button !== 0) return;
    e.preventDefault();
    e.stopPropagation();
    const startX = e.clientX;
    const startTotalW = columns.length * colWidth;
    const numCols = columns.length;
    handle.classList.add('active');

    function onMove(ev) {
      const dx = ev.clientX - startX;
      const newTotalW = Math.max(numCols * 20, startTotalW + dx);
      const newCW = Math.max(20, Math.round(newTotalW / numCols));
      if (newCW !== colWidth) {
        customColWidth = newCW;
        colWidth = newCW;
        document.documentElement.style.setProperty('--col-width', colWidth + 'px');
        render();
      }
    }

    function onUp() {
      document.removeEventListener('mousemove', onMove);
      document.removeEventListener('mouseup', onUp);
      handle.classList.remove('active');
    }

    document.addEventListener('mousemove', onMove);
    document.addEventListener('mouseup', onUp);
  });
}

// ===== Sidebar Resize Handle =====
function initSidebarResizeHandle() {
  const handle = document.getElementById('sidebar-resize-handle');

  handle.addEventListener('mousedown', e => {
    if (e.button !== 0) return;
    e.preventDefault();
    e.stopPropagation();
    const startX = e.clientX;
    const startWidth = parseInt(getComputedStyle(document.documentElement).getPropertyValue('--sidebar-width'));
    handle.classList.add('active');

    function onMove(ev) {
      const dx = ev.clientX - startX;
      const newWidth = Math.max(80, Math.min(600, startWidth + dx));
      document.documentElement.style.setProperty('--sidebar-width', newWidth + 'px');
      render();
    }

    function onUp() {
      document.removeEventListener('mousemove', onMove);
      document.removeEventListener('mouseup', onUp);
      handle.classList.remove('active');
    }

    document.addEventListener('mousemove', onMove);
    document.addEventListener('mouseup', onUp);
  });
}

// ===== Body Height Resize Handle =====
function initBodyHeightResizeHandle() {
  const handle = document.getElementById('body-height-resize-handle');

  handle.addEventListener('mousedown', e => {
    if (e.button !== 0) return;
    e.preventDefault();
    e.stopPropagation();
    const startY = e.clientY;
    const startHeight = totalBodyHeight;
    handle.classList.add('active');

    function onMove(ev) {
      const dy = ev.clientY - startY;
      const newHeight = Math.max(visibleRows.length * 20, startHeight + dy);
      customBodyHeight = newHeight;
      render();
    }

    function onUp() {
      document.removeEventListener('mousemove', onMove);
      document.removeEventListener('mouseup', onUp);
      handle.classList.remove('active');
    }

    document.addEventListener('mousemove', onMove);
    document.addEventListener('mouseup', onUp);
  });
}

// ===== Init =====
document.addEventListener('DOMContentLoaded', () => {
  document.body.classList.add('edit-mode');
  document.getElementById('thunder-default-date').value = state.thunderLine.defaultDate;
  document.getElementById('view-start').value = state.startDate;
  document.getElementById('view-end').value = state.endDate;
  updateUIText();
  initResizeHandle();
  initSidebarResizeHandle();
  initBodyHeightResizeHandle();

  // Corner label editing
  const corner = document.getElementById('gantt-corner');
  corner.addEventListener('blur', () => {
    const text = corner.textContent.trim();
    state.cornerLabel = text === t('taskName') ? '' : text;
  });
  corner.addEventListener('keydown', e => {
    if (e.key === 'Enter') { e.preventDefault(); corner.blur(); }
  });

  // Load JSON from URL parameter if specified
  const urlParam = new URLSearchParams(window.location.search).get('url');
  if (urlParam) {
    fetch(urlParam)
      .then(res => {
        if (!res.ok) throw new Error(`HTTP ${res.status}`);
        return res.json();
      })
      .then(data => {
        if (!applyJSONData(data)) alert(t('invalidFile'));
      })
      .catch(err => alert(t('jsonError') + err.message));
  }

  render();

  // File drag & drop import
  document.addEventListener('dragover', e => { e.preventDefault(); });
  document.addEventListener('drop', e => {
    e.preventDefault();
    const file = e.dataTransfer.files[0];
    if (file && file.name.endsWith('.json')) {
      loadJSONFile(file);
    }
  });
});

// Keyboard
document.addEventListener('keydown', e => {
  if (e.key === 'z' && (e.ctrlKey || e.metaKey) && !e.shiftKey) {
    if (!document.querySelector('.modal-overlay') && document.activeElement.tagName !== 'INPUT' && !document.activeElement.isContentEditable) {
      e.preventDefault();
      undo();
    }
  }
  if (e.key === 'Delete' || e.key === 'Backspace') {
    if (appMode === 'edit' && selectedItems.length > 0 && !document.querySelector('.modal-overlay') && document.activeElement.tagName !== 'INPUT' && !document.activeElement.isContentEditable) {
      e.preventDefault();
      deleteSelected();
    }
  }
  if (e.key === 'Escape') {
    hideContextMenu();
    const overlay = document.querySelector('.modal-overlay');
    if (overlay) overlay.remove();
    if (selectedItems.length > 0) { clearSelection(); render(); }
  }
});
</script>
</body>
</html>
